Index: library/src/main/java/com/daimajia/slider/library/Animations/BaseAnimationInterface.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Animations/BaseAnimationInterface.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Animations/BaseAnimationInterface.java	(revision )
@@ -0,0 +1,46 @@
+package com.daimajia.slider.library.Animations;
+
+import android.view.View;
+
+/**
+ * This interface gives you chance to inject your own animation or do something when the
+ * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} animation (PagerTransformer) starts or ends.
+ *
+ *
+ * There are two items you have to know. The first item is the slider you are dragging. This item
+ * I call it Current Item. The second is the slider that gonna to show. I call that Next Item.
+ *
+ * When you start to drag the slider in front of you, onPrepareCurrentItemLeaveScreen() and
+ * onPrepareNextItemShowInScreen will be called.
+ *
+ * When you finish drag, the onCurrentItemDisappear and onNextItemAppear will be invoked.
+ *
+ * You can see a demo class {@link com.daimajia.slider.library.Animations.DescriptionAnimation},
+ * this class gives the description text an animation.
+ */
+public interface BaseAnimationInterface {
+
+    /**
+     * When the current item prepare to start leaving the screen.
+     * @param current
+     */
+    public void onPrepareCurrentItemLeaveScreen(View current);
+
+    /**
+     * The next item which will be shown in ViewPager/
+     * @param next
+     */
+    public void onPrepareNextItemShowInScreen(View next);
+
+    /**
+     * Current item totally disappear from screen.
+     * @param view
+     */
+    public void onCurrentItemDisappear(View view);
+
+    /**
+     * Next item totally show in screen.
+     * @param view
+     */
+    public void onNextItemAppear(View view);
+}
Index: demo/proguard-rules.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/proguard-rules.txt	(revision )
+++ demo/proguard-rules.txt	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
\ No newline at end of file
Index: library/gradle-mvn-push.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/gradle-mvn-push.gradle	(revision )
+++ library/gradle-mvn-push.gradle	(revision )
@@ -0,0 +1,133 @@
+/*
+ * Copyright 2013 Chris Banes
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+def isReleaseBuild() {
+    return VERSION_NAME.contains("SNAPSHOT") == false
+}
+
+def getReleaseRepositoryUrl() {
+    return hasProperty('RELEASE_REPOSITORY_URL') ? RELEASE_REPOSITORY_URL
+            : "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+}
+
+def getSnapshotRepositoryUrl() {
+    return hasProperty('SNAPSHOT_REPOSITORY_URL') ? SNAPSHOT_REPOSITORY_URL
+            : "https://oss.sonatype.org/content/repositories/snapshots/"
+}
+
+def getRepositoryUsername() {
+    return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
+}
+
+def getRepositoryPassword() {
+    return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
+}
+
+afterEvaluate { project ->
+    uploadArchives {
+        repositories {
+            mavenDeployer {
+                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+                pom.groupId = GROUP
+                pom.artifactId = POM_ARTIFACT_ID
+                pom.version = VERSION_NAME
+
+                repository(url: getReleaseRepositoryUrl()) {
+                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+                }
+                snapshotRepository(url: getSnapshotRepositoryUrl()) {
+                    authentication(userName: getRepositoryUsername(), password: getRepositoryPassword())
+                }
+
+                pom.project {
+                    name POM_NAME
+                    packaging POM_PACKAGING
+                    description POM_DESCRIPTION
+                    url POM_URL
+
+                    scm {
+                        url POM_SCM_URL
+                        connection POM_SCM_CONNECTION
+                        developerConnection POM_SCM_DEV_CONNECTION
+                    }
+
+                    licenses {
+                        license {
+                            name POM_LICENCE_NAME
+                            url POM_LICENCE_URL
+                            distribution POM_LICENCE_DIST
+                        }
+                    }
+
+                    developers {
+                        developer {
+                            id POM_DEVELOPER_ID
+                            name POM_DEVELOPER_NAME
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    signing {
+        required { isReleaseBuild() && gradle.taskGraph.hasTask("uploadArchives") }
+        sign configurations.archives
+    }
+
+    task apklib(type: Zip){
+        appendix = extension = 'apklib'
+
+        from 'AndroidManifest.xml'
+        into('res') {
+            from 'res'
+        }
+        into('src') {
+            from 'src'
+        }
+    }
+
+
+    task androidJavadocs(type: Javadoc) {
+        source = android.sourceSets.main.java.srcDirs
+        classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+        options.links("http://docs.oracle.com/javase/7/docs/api/");
+        options.linksOffline "http://d.android.com/reference","${android.sdkDirectory}/docs/reference"
+        exclude '**/BuildConfig.java'
+        exclude '**/R.java'
+        failOnError = false
+    }
+
+    task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
+        classifier = 'javadoc'
+        from androidJavadocs.destinationDir
+    }
+
+    task androidSourcesJar(type: Jar) {
+        classifier = 'sources'
+        from android.sourceSets.main.java.sourceFiles
+    }
+
+    artifacts {
+        archives androidSourcesJar
+        archives androidJavadocsJar
+        archives apklib
+    }
+}
\ No newline at end of file
Index: library/src/main/java/com/daimajia/slider/library/Transformers/RotateDownTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/RotateDownTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/RotateDownTransformer.java	(revision )
@@ -0,0 +1,27 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class RotateDownTransformer extends BaseTransformer {
+
+	private static final float ROT_MOD = -15f;
+
+	@Override
+	protected void onTransform(View view, float position) {
+		final float width = view.getWidth();
+		final float height = view.getHeight();
+		final float rotation = ROT_MOD * position * -1.25f;
+
+		ViewHelper.setPivotX(view,width * 0.5f);
+        ViewHelper.setPivotY(view,height);
+        ViewHelper.setRotation(view,rotation);
+	}
+	
+	@Override
+	protected boolean isPagingEnabled() {
+		return true;
+	}
+
+}
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- build.gradle	(revision )
+++ build.gradle	(revision )
@@ -0,0 +1,21 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+
+task wrapper(type: Wrapper) {
+    gradleVersion = '2.2.1' 
+}
+
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:2.3.3'
+        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.10.1'
+    }
+}
+
+allprojects {
+    repositories {
+        mavenCentral()
+    }
+}
Index: library/src/main/res/values/styles.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/res/values/styles.xml	(revision )
+++ library/src/main/res/values/styles.xml	(revision )
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <style name="AndroidImageSlider_Corner_Oval_Orange">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:gravity">center</item>
+        <item name="android:background">@drawable/indicator_corner_bg</item>
+        <item name="android:paddingLeft">2dp</item>
+        <item name="android:paddingRight">2dp</item>
+        <item name="shape">oval</item>
+        <item name="padding_left">3dp</item>
+        <item name="padding_right">3dp</item>
+        <item name="padding_top">4dp</item>
+        <item name="padding_bottom">4dp</item>
+
+        <item name="selected_color">#f60</item>
+        <item name="unselected_color">#ffffff</item>
+        <item name="selected_width">6dp</item>
+        <item name="selected_height">6dp</item>
+        <item name="unselected_width">6dp</item>
+        <item name="unselected_height">6dp</item>
+    </style>
+
+    <style name="AndroidImageSlider_Attractive_Rect_Blue">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:gravity">center</item>
+        <item name="android:paddingLeft">2dp</item>
+        <item name="android:paddingRight">2dp</item>
+        <item name="shape">rect</item>
+        <item name="padding_left">3dp</item>
+        <item name="padding_right">3dp</item>
+        <item name="padding_top">4dp</item>
+        <item name="padding_bottom">4dp</item>
+
+        <item name="selected_color">#30CCE5</item>
+        <item name="unselected_color">#333333</item>
+        <item name="selected_width">13dp</item>
+        <item name="selected_height">4dp</item>
+        <item name="unselected_width">13dp</item>
+        <item name="unselected_height">4dp</item>
+    </style>
+
+    <style name="AndroidImageSlider_Magnifier_Oval_Black">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:gravity">center</item>
+        <item name="android:paddingLeft">2dp</item>
+        <item name="android:paddingRight">2dp</item>
+        <item name="shape">oval</item>
+        <item name="padding_left">3dp</item>
+        <item name="padding_right">3dp</item>
+        <item name="padding_top">4dp</item>
+        <item name="padding_bottom">4dp</item>
+
+        <item name="selected_color">#333333</item>
+        <item name="unselected_color">#33000000</item>
+        <item name="selected_width">8dp</item>
+        <item name="selected_height">8dp</item>
+        <item name="unselected_width">6dp</item>
+        <item name="unselected_height">6dp</item>
+    </style>
+</resources>
\ No newline at end of file
Index: library/src/main/java/com/daimajia/slider/library/Transformers/AccordionTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/AccordionTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/AccordionTransformer.java	(revision )
@@ -0,0 +1,18 @@
+package com.daimajia.slider.library.Transformers;
+
+/**
+ * Created by daimajia on 14-5-29.
+ */
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class AccordionTransformer extends BaseTransformer {
+
+    @Override
+    protected void onTransform(View view, float position) {
+        ViewHelper.setPivotX(view,position < 0 ? 0 : view.getWidth());
+        ViewHelper.setScaleX(view,position < 0 ? 1f + position : 1f - position);
+    }
+
+}
\ No newline at end of file
Index: library/src/main/java/com/daimajia/slider/library/Transformers/BackgroundToForegroundTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/BackgroundToForegroundTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/BackgroundToForegroundTransformer.java	(revision )
@@ -0,0 +1,26 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class BackgroundToForegroundTransformer extends BaseTransformer {
+
+	@Override
+	protected void onTransform(View view, float position) {
+		final float height = view.getHeight();
+		final float width = view.getWidth();
+		final float scale = min(position < 0 ? 1f : Math.abs(1f - position), 0.5f);
+
+        ViewHelper.setScaleX(view,scale);
+        ViewHelper.setScaleY(view,scale);
+        ViewHelper.setPivotX(view,width*0.5f);
+        ViewHelper.setPivotY(view,height*0.5f);
+        ViewHelper.setTranslationX(view,position < 0 ? width * position : -width * position * 0.25f);
+	}
+
+	private static final float min(float val, float min) {
+		return val < min ? min : val;
+	}
+
+}
Index: library/src/main/java/com/daimajia/slider/library/Transformers/FadeTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/FadeTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/FadeTransformer.java	(revision )
@@ -0,0 +1,33 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+/**
+ * Created by realandylawton on 11/22/13.
+ */
+public class FadeTransformer extends BaseTransformer {
+
+    @Override
+    protected void onTransform(View view, float position) {
+
+        // Page is not an immediate sibling, just make transparent
+        if(position < -1 || position > 1) {
+            ViewHelper.setAlpha(view,0.6f);
+        }
+        // Page is sibling to left or right
+        else if (position <= 0 || position <= 1) {
+
+            // Calculate alpha.  Position is decimal in [-1,0] or [0,1]
+            float alpha = (position <= 0) ? position + 1 : 1 - position;
+            ViewHelper.setAlpha(view,alpha);
+
+        }
+        // Page is active, make fully visible
+        else if (position == 0) {
+            ViewHelper.setAlpha(view,1);
+        }
+    }
+
+}
\ No newline at end of file
Index: demo/src/main/res/layout/activity_main.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/res/layout/activity_main.xml	(revision )
+++ demo/src/main/res/layout/activity_main.xml	(revision )
@@ -0,0 +1,52 @@
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:custom="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context="com.daimajia.slider.demo.MainActivity">
+    <com.daimajia.slider.library.SliderLayout
+        android:id="@+id/slider"
+        android:layout_width="match_parent"
+        custom:pager_animation="Accordion"
+        custom:auto_cycle="true"
+        custom:indicator_visibility="visible"
+        custom:pager_animation_span="1100"
+        android:layout_height="200dp"/>
+
+    <com.daimajia.slider.library.Indicators.PagerIndicator
+        android:id="@+id/custom_indicator"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        custom:selected_color="#0095BF"
+        custom:unselected_color="#55333333"
+        custom:selected_drawable="@drawable/bird"
+        custom:shape="oval"
+        custom:selected_padding_left="5dp"
+        custom:selected_padding_right="5dp"
+        custom:unselected_padding_left="5dp"
+        custom:unselected_padding_right="5dp"
+        android:layout_centerHorizontal="true"
+        android:layout_alignParentBottom="true"
+        custom:selected_width="6dp"
+        custom:selected_height="6dp"
+        custom:unselected_width="6dp"
+        custom:unselected_height="6dp"
+        android:layout_marginBottom="20dp"
+        />
+    <com.daimajia.slider.library.Indicators.PagerIndicator
+        android:id="@+id/custom_indicator2"
+        style="@style/AndroidImageSlider_Corner_Oval_Orange"
+        android:layout_centerHorizontal="true"
+        android:layout_alignParentBottom="true"
+        android:layout_marginBottom="20dp"
+        />
+    <ListView
+        android:layout_below="@+id/slider"
+        android:id="@+id/transformers"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"></ListView>
+
+
+</RelativeLayout>
Index: library/src/main/java/com/daimajia/slider/library/Transformers/TabletTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/TabletTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/TabletTransformer.java	(revision )
@@ -0,0 +1,40 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.graphics.Camera;
+import android.graphics.Matrix;
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class TabletTransformer extends BaseTransformer {
+
+	private static final Matrix OFFSET_MATRIX = new Matrix();
+	private static final Camera OFFSET_CAMERA = new Camera();
+	private static final float[] OFFSET_TEMP_FLOAT = new float[2];
+
+	@Override
+	protected void onTransform(View view, float position) {
+		final float rotation = (position < 0 ? 30f : -30f) * Math.abs(position);
+
+		ViewHelper.setTranslationX(view,getOffsetXForRotation(rotation, view.getWidth(), view.getHeight()));
+        ViewHelper.setPivotX(view,view.getWidth() * 0.5f);
+        ViewHelper.setPivotY(view,0);
+        ViewHelper.setRotationY(view,rotation);
+	}
+
+	protected static final float getOffsetXForRotation(float degrees, int width, int height) {
+		OFFSET_MATRIX.reset();
+		OFFSET_CAMERA.save();
+		OFFSET_CAMERA.rotateY(Math.abs(degrees));
+		OFFSET_CAMERA.getMatrix(OFFSET_MATRIX);
+		OFFSET_CAMERA.restore();
+
+		OFFSET_MATRIX.preTranslate(-width * 0.5f, -height * 0.5f);
+		OFFSET_MATRIX.postTranslate(width * 0.5f, height * 0.5f);
+		OFFSET_TEMP_FLOAT[0] = width;
+		OFFSET_TEMP_FLOAT[1] = height;
+		OFFSET_MATRIX.mapPoints(OFFSET_TEMP_FLOAT);
+		return (width - OFFSET_TEMP_FLOAT[0]) * (degrees > 0.0f ? 1.0f : -1.0f);
+	}
+
+}
Index: library/src/main/res/layout/slider_layout.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/res/layout/slider_layout.xml	(revision )
+++ library/src/main/res/layout/slider_layout.xml	(revision )
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:custom="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent" android:layout_height="match_parent">
+
+    <com.daimajia.slider.library.Tricks.InfiniteViewPager
+        android:id="@+id/daimajia_slider_viewpager"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+    <com.daimajia.slider.library.Indicators.PagerIndicator
+        android:id="@+id/default_center_bottom_indicator"
+        android:layout_alignParentBottom="true"
+        android:layout_centerHorizontal="true"
+        android:paddingBottom="10dp"
+        android:gravity="center"
+        custom:shape="oval"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+    <com.daimajia.slider.library.Indicators.PagerIndicator
+        android:id="@+id/default_bottom_right_indicator"
+        android:layout_alignParentBottom="true"
+        android:layout_alignParentRight="true"
+        android:gravity="center"
+        android:paddingBottom="10dp"
+        android:paddingRight="10dp"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+    <com.daimajia.slider.library.Indicators.PagerIndicator
+        android:id="@+id/default_bottom_left_indicator"
+        android:gravity="center"
+        android:layout_alignParentBottom="true"
+        android:layout_alignParentLeft="true"
+        android:paddingBottom="10dp"
+        android:paddingLeft="10dp"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+    <com.daimajia.slider.library.Indicators.PagerIndicator
+        android:id="@+id/default_center_top_indicator"
+        android:gravity="center"
+        android:layout_alignParentTop="true"
+        android:layout_centerHorizontal="true"
+        android:paddingTop="10dp"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+    <com.daimajia.slider.library.Indicators.PagerIndicator
+        android:id="@+id/default_center_top_right_indicator"
+        android:layout_alignParentTop="true"
+        android:gravity="center"
+        android:layout_alignParentRight="true"
+        android:paddingTop="10dp"
+        android:paddingRight="10dp"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+    <com.daimajia.slider.library.Indicators.PagerIndicator
+        android:id="@+id/default_center_top_left_indicator"
+        android:layout_alignParentTop="true"
+        android:gravity="center"
+        android:layout_alignParentLeft="true"
+        android:paddingTop="10dp"
+        android:paddingLeft="10dp"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+</RelativeLayout>
\ No newline at end of file
Index: library/src/main/java/com/daimajia/slider/library/Transformers/FlipPageViewTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/FlipPageViewTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/FlipPageViewTransformer.java	(revision )
@@ -0,0 +1,49 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.os.Build;
+import android.view.View;
+
+import com.daimajia.slider.library.Tricks.ViewPagerEx;
+import com.nineoldandroids.view.ViewHelper;
+
+public class FlipPageViewTransformer extends BaseTransformer {
+
+    @Override
+    protected void onTransform(View view, float position) {
+        float percentage = 1 - Math.abs(position);
+        if(Build.VERSION.SDK_INT >= 13){
+            view.setCameraDistance(12000);
+        }
+        setVisibility(view, position);
+        setTranslation(view);
+        setSize(view, position, percentage);
+        setRotation(view, position, percentage);
+    }
+
+    private void setVisibility(View page, float position) {
+        if (position < 0.5 && position > -0.5) {
+            page.setVisibility(View.VISIBLE);
+        } else {
+            page.setVisibility(View.INVISIBLE);
+        }
+    }
+
+    private void setTranslation(View view) {
+        ViewPagerEx viewPager = (ViewPagerEx) view.getParent();
+        int scroll = viewPager.getScrollX() - view.getLeft();
+        ViewHelper.setTranslationX(view,scroll);
+    }
+
+    private void setSize(View view, float position, float percentage) {
+        ViewHelper.setScaleX(view,(position != 0 && position != 1) ? percentage : 1);
+        ViewHelper.setScaleY(view,(position != 0 && position != 1) ? percentage : 1);
+    }
+
+    private void setRotation(View view, float position, float percentage) {
+        if (position > 0) {
+            ViewHelper.setRotationY(view,-180 * (percentage + 1));
+        } else {
+            ViewHelper.setRotationY(view,180 * (percentage + 1));
+        }
+    }
+}
\ No newline at end of file
Index: demo/src/main/res/menu/main.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/res/menu/main.xml	(revision )
+++ demo/src/main/res/menu/main.xml	(revision )
@@ -0,0 +1,23 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context="com.daimajia.slider.demo.MainActivity" >
+    <item android:id="@+id/action_custom_indicator"
+        android:title="Custom Indicator"
+        android:orderInCategory="100"
+        app:showAsAction="never" />
+    <item android:id="@+id/action_custom_child_animation"
+        android:title="ChildView Animation"
+        android:orderInCategory="100"
+        app:showAsAction="never" />
+    <item android:id="@+id/action_restore_default"
+        android:orderInCategory="100"
+        app:showAsAction="never"
+        android:title="Restore default"/>
+    <item android:id="@+id/action_github"
+        android:orderInCategory="100"
+        app:showAsAction="never"
+        android:title="GitHub"
+        >
+    </item>
+</menu>
Index: library/gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- library/gradle.properties	(revision )
+++ library/gradle.properties	(revision )
@@ -0,0 +1,22 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Settings specified in this file will override any Gradle settings
+# configured through the IDE.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
+
+POM_NAME=AndroidImageSlider Library
+POM_ARTIFACT_ID=library
+POM_PACKAGING=aar
Index: gradle/wrapper/gradle-wrapper.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- gradle/wrapper/gradle-wrapper.properties	(revision )
+++ gradle/wrapper/gradle-wrapper.properties	(revision )
@@ -0,0 +1,6 @@
+#Sun Nov 26 21:40:25 CST 2017
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
Index: demo/src/main/res/values/dimens.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/res/values/dimens.xml	(revision )
+++ demo/src/main/res/values/dimens.xml	(revision )
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
Index: demo/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/build.gradle	(revision )
+++ demo/build.gradle	(revision )
@@ -0,0 +1,24 @@
+apply plugin: 'com.android.application'
+//apply plugin: 'android-sdk-manager'
+
+android {
+    compileSdkVersion 26
+    buildToolsVersion '26.0.1'
+
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 26
+        versionCode 2
+        versionName "1.0.1"
+    }
+    buildTypes {
+        release {
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile project(':library')
+}
Index: library/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/AndroidManifest.xml	(revision )
+++ library/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,5 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.daimajia.slider.library">
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+</manifest>
\ No newline at end of file
Index: demo/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/res/values/strings.xml	(revision )
+++ demo/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">AndroidImageSlider</string>
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings">Settings</string>
+
+</resources>
Index: demo/src/main/java/com/daimajia/slider/demo/ChildAnimationExample.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/java/com/daimajia/slider/demo/ChildAnimationExample.java	(revision )
+++ demo/src/main/java/com/daimajia/slider/demo/ChildAnimationExample.java	(revision )
@@ -0,0 +1,51 @@
+package com.daimajia.slider.demo;
+
+import android.util.Log;
+import android.view.View;
+
+import com.daimajia.androidanimations.library.attention.StandUpAnimator;
+import com.daimajia.slider.library.Animations.BaseAnimationInterface;
+
+public class ChildAnimationExample implements BaseAnimationInterface {
+
+    private final static String TAG = "ChildAnimationExample";
+
+    @Override
+    public void onPrepareCurrentItemLeaveScreen(View current) {
+        View descriptionLayout = current.findViewById(com.daimajia.slider.library.R.id.description_layout);
+        if(descriptionLayout!=null){
+            current.findViewById(com.daimajia.slider.library.R.id.description_layout).setVisibility(View.INVISIBLE);
+        }
+        Log.e(TAG,"onPrepareCurrentItemLeaveScreen called");
+    }
+
+    @Override
+    public void onPrepareNextItemShowInScreen(View next) {
+        View descriptionLayout = next.findViewById(com.daimajia.slider.library.R.id.description_layout);
+        if(descriptionLayout!=null){
+            next.findViewById(com.daimajia.slider.library.R.id.description_layout).setVisibility(View.INVISIBLE);
+        }
+        Log.e(TAG,"onPrepareNextItemShowInScreen called");
+    }
+
+    @Override
+    public void onCurrentItemDisappear(View view) {
+        Log.e(TAG,"onCurrentItemDisappear called");
+    }
+
+    @Override
+    public void onNextItemAppear(View view) {
+
+        View descriptionLayout = view.findViewById(com.daimajia.slider.library.R.id.description_layout);
+        if(descriptionLayout!=null){
+            view.findViewById(com.daimajia.slider.library.R.id.description_layout).setVisibility(View.VISIBLE);
+//            ValueAnimator animator = ObjectAnimator.ofFloat(
+//                    descriptionLayout, "y", -descriptionLayout.getHeight(),
+//                    0).setDuration(500);
+//            animator.start();
+//            new BounceInAnimator().animate(descriptionLayout);
+            new StandUpAnimator().animate(descriptionLayout);
+        }
+        Log.e(TAG,"onCurrentItemDisappear called");
+    }
+}
Index: gradlew
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- gradlew	(revision )
+++ gradlew	(revision )
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .gitignore	(revision )
+++ .gitignore	(revision )
@@ -0,0 +1,38 @@
+# built application files
+*.apk
+*.ap_
+
+# files for the dex VM
+*.dex
+
+# Java class files
+*.class
+.DS_Store
+
+# generated files
+bin/
+gen/
+Wiki/
+
+# Local configuration file (sdk path, etc)
+local.properties
+
+# Eclipse project files
+.classpath
+.project
+.settings/
+
+# Proguard folder generated by Eclipse
+proguard/
+
+#Android Studio
+build/
+
+# Intellij project files
+*.iml
+*.ipr
+*.iws
+.idea/
+
+#gradle
+.gradle/
\ No newline at end of file
Index: demo/src/main/res/layout/item.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/res/layout/item.xml	(revision )
+++ demo/src/main/res/layout/item.xml	(revision )
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="50dp"
+    android:id="@+id/list_item_text"
+    android:textSize="16sp"
+    android:gravity="left|center_vertical"
+    android:padding="10dp" />
\ No newline at end of file
Index: library/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/.gitignore	(revision )
+++ library/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: library/src/main/java/com/daimajia/slider/library/SliderTypes/DefaultSliderView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/SliderTypes/DefaultSliderView.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/SliderTypes/DefaultSliderView.java	(revision )
@@ -0,0 +1,28 @@
+package com.daimajia.slider.library.SliderTypes;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.daimajia.slider.library.R;
+
+/**
+ * a simple slider view, which just show an image. If you want to make your own slider view,
+ *
+ * just extend BaseSliderView, and implement getView() method.
+ */
+public class DefaultSliderView extends BaseSliderView{
+
+    public DefaultSliderView(Context context) {
+        super(context);
+    }
+
+    @Override
+    public View getView() {
+        View v = LayoutInflater.from(getContext()).inflate(R.layout.render_type_default,null);
+        ImageView target = (ImageView)v.findViewById(R.id.daimajia_slider_image);
+        bindEventAndShow(v, target);
+        return v;
+    }
+}
Index: library/src/main/java/com/daimajia/slider/library/Animations/DescriptionAnimation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Animations/DescriptionAnimation.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Animations/DescriptionAnimation.java	(revision )
@@ -0,0 +1,61 @@
+package com.daimajia.slider.library.Animations;
+
+import android.view.View;
+
+import com.daimajia.slider.library.R;
+import com.nineoldandroids.animation.ObjectAnimator;
+import com.nineoldandroids.animation.ValueAnimator;
+import com.nineoldandroids.view.ViewHelper;
+
+/**
+ * A demo class to show how to use {@link com.daimajia.slider.library.Animations.BaseAnimationInterface}
+ * to make  your custom animation in {@link com.daimajia.slider.library.Tricks.ViewPagerEx.PageTransformer} action.
+ */
+public class DescriptionAnimation implements BaseAnimationInterface {
+
+    @Override
+    public void onPrepareCurrentItemLeaveScreen(View current) {
+        View descriptionLayout = current.findViewById(R.id.description_layout);
+        if(descriptionLayout!=null){
+            current.findViewById(R.id.description_layout).setVisibility(View.INVISIBLE);
+        }
+    }
+
+    /**
+     * When next item is coming to show, let's hide the description layout.
+     * @param next
+     */
+    @Override
+    public void onPrepareNextItemShowInScreen(View next) {
+        View descriptionLayout = next.findViewById(R.id.description_layout);
+        if(descriptionLayout!=null){
+            next.findViewById(R.id.description_layout).setVisibility(View.INVISIBLE);
+        }
+    }
+
+
+    @Override
+    public void onCurrentItemDisappear(View view) {
+
+    }
+
+    /**
+     * When next item show in ViewPagerEx, let's make an animation to show the
+     * description layout.
+     * @param view
+     */
+    @Override
+    public void onNextItemAppear(View view) {
+
+        View descriptionLayout = view.findViewById(R.id.description_layout);
+        if(descriptionLayout!=null){
+            float layoutY = ViewHelper.getY(descriptionLayout);
+            view.findViewById(R.id.description_layout).setVisibility(View.VISIBLE);
+            ValueAnimator animator = ObjectAnimator.ofFloat(
+                    descriptionLayout,"y",layoutY + descriptionLayout.getHeight(),
+                    layoutY).setDuration(500);
+            animator.start();
+        }
+
+    }
+}
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- README.md	(revision )
+++ README.md	(revision )
@@ -0,0 +1,113 @@
+# Android Image Slider [![Build Status](https://travis-ci.org/daimajia/AndroidImageSlider.svg)](https://travis-ci.org/daimajia/AndroidImageSlider)
+
+[![Gitter](https://badges.gitter.im/Join Chat.svg)](https://gitter.im/daimajia/AndroidImageSlider?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
+ 
+This is an amazing image slider for the Android platform. I decided to open source this because there is really not an attractive, convenient slider widget in Android.
+ 
+You can easily load images from an internet URL, drawable, or file. And there are many kinds of amazing animations you can choose. :-D
+ 
+## Demo
+ 
+![](http://ww3.sinaimg.cn/mw690/610dc034jw1egzor66ojdg20950fknpe.gif)
+
+[Download Apk](https://github.com/daimajia/AndroidImageSlider/releases/download/v1.0.8/demo-1.0.8.apk)
+ 
+## Usage
+
+### Step 1
+
+#### Gradle
+
+```groovy
+dependencies {
+    	compile "com.android.support:support-v4:+"
+    	compile 'com.squareup.picasso:picasso:2.3.2'
+    	compile 'com.nineoldandroids:library:2.4.0'
+    	compile 'com.daimajia.slider:library:1.1.5@aar'
+}
+```
+
+
+#### Maven
+
+```xml
+<dependency>
+    <groupId>com.squareup.picasso</groupId>
+    <artifactId>picasso</artifactId>
+    <version>2.3.2</version>
+</dependency>
+<dependency>
+    <groupId>com.nineoldandroids</groupId>
+    <artifactId>library</artifactId>
+    <version>2.4.0</version>
+</dependency>
+<dependency>
+    <groupId>com.daimajia.slider</groupId>
+    <artifactId>library</artifactId>
+    <version>1.1.2</version>
+    <type>apklib</type>
+</dependency>
+```
+
+#### Eclipse
+
+For Eclipse users, I provided a sample project which orgnized as Eclipse way. You can download it from [here](https://github.com/daimajia/AndroidImageSlider/releases/download/v1.0.9/AndroidImageSlider-Eclipse.zip), and make some changes to fit your project.
+
+Notice: It's the version of 1.0.9, it may not update any more. You can update manually by yourself.
+
+### Step 2
+
+Add permissions (if necessary) to your `AndroidManifest.xml`
+
+```xml
+<!-- if you want to load images from the internet -->
+<uses-permission android:name="android.permission.INTERNET" /> 
+
+<!-- if you want to load images from a file OR from the internet -->
+<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+```
+
+**Note:** If you want to load images from the internet, you need both the `INTERNET` and `READ_EXTERNAL_STORAGE` permissions to allow files from the internet to be cached into local storage.
+
+If you want to load images from drawable, then no additional permissions are necessary.
+
+### Step 3
+
+Add the Slider to your layout:
+ 
+```java
+<com.daimajia.slider.library.SliderLayout
+        android:id="@+id/slider"
+        android:layout_width="match_parent"
+        android:layout_height="200dp"
+/>
+```        
+ 
+There are some default indicators. If you want to use a provided indicator:
+ 
+```java
+<com.daimajia.slider.library.Indicators.PagerIndicator
+        android:id="@+id/custom_indicator"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        />
+```
+
+[Code example](https://github.com/daimajia/AndroidImageSlider/blob/master/demo%2Fsrc%2Fmain%2Fjava%2Fcom%2Fdaimajia%2Fslider%2Fdemo%2FMainActivity.java)
+ 
+====
+ 
+## Advanced usage
+
+Please visit [Wiki](https://github.com/daimajia/AndroidImageSlider/wiki)
+ 
+## Thanks
+
+- [Picasso](https://github.com/square/picasso)
+- [NineOldAndroids](https://github.com/JakeWharton/NineOldAndroids)
+- [ViewPagerTransforms](https://github.com/ToxicBakery/ViewPagerTransforms)
+
+##About me
+ 
+I am a student in mainland China. I love Google, love Android, love everything that is interesting. If you get any problems when using this library or you have an internship opportunity, please feel free to [email me](mailto:daimajia@gmail.com). :smiley:
Index: library/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/build.gradle	(revision )
+++ library/build.gradle	(revision )
@@ -0,0 +1,31 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 26
+    buildToolsVersion '26.0.1'
+
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion 26
+        versionCode 15
+        versionName "1.1.5"
+    }
+    buildTypes {
+        release {
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+    lintOptions {
+          abortOnError false
+      }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile 'com.android.support:appcompat-v7:26.0.0-alpha1'
+    compile "com.android.support:support-v4:26.0.0-alpha1"
+    compile 'com.squareup.picasso:picasso:2.5.2'
+    compile 'com.nineoldandroids:library:2.4.0'
+    compile 'com.daimajia.androidanimations:library:1.0.3@aar'
+}
+apply from: './gradle-mvn-push.gradle'
Index: library/src/main/java/com/daimajia/slider/library/Transformers/ZoomInTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/ZoomInTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/ZoomInTransformer.java	(revision )
@@ -0,0 +1,19 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class ZoomInTransformer extends BaseTransformer {
+
+	@Override
+	protected void onTransform(View view, float position) {
+		final float scale = position < 0 ? position + 1f : Math.abs(1f - position);
+		ViewHelper.setScaleX(view,scale);
+        ViewHelper.setScaleY(view,scale);
+        ViewHelper.setPivotX(view,view.getWidth() * 0.5f);
+        ViewHelper.setPivotY(view,view.getHeight() * 0.5f);
+        ViewHelper.setAlpha(view,position < -1f || position > 1f ? 0f : 1f - (scale - 1f));
+	}
+
+}
Index: library/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/res/values/strings.xml	(revision )
+++ library/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">Slider</string>
+</resources>
Index: library/src/main/java/com/daimajia/slider/library/Indicators/PagerIndicator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Indicators/PagerIndicator.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Indicators/PagerIndicator.java	(revision )
@@ -0,0 +1,472 @@
+package com.daimajia.slider.library.Indicators;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.database.DataSetObserver;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import android.graphics.drawable.LayerDrawable;
+import android.support.v4.view.PagerAdapter;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+
+import com.daimajia.slider.library.R;
+import com.daimajia.slider.library.Tricks.InfinitePagerAdapter;
+import com.daimajia.slider.library.Tricks.ViewPagerEx;
+
+import java.util.ArrayList;
+
+/**
+ * Pager Indicator.
+ */
+public class PagerIndicator extends LinearLayout implements ViewPagerEx.OnPageChangeListener{
+
+    private Context mContext;
+
+    /**
+     * bind this Indicator with {@link com.daimajia.slider.library.Tricks.ViewPagerEx}
+     */
+    private ViewPagerEx mPager;
+
+    /**
+     * Variable to remember the previous selected indicator.
+     */
+    private ImageView mPreviousSelectedIndicator;
+
+    /**
+     * Previous selected indicator position.
+     */
+    private int mPreviousSelectedPosition;
+
+    /**
+     * Custom selected indicator style resource id.
+     */
+    private int mUserSetUnSelectedIndicatorResId;
+
+
+    /**
+     * Custom unselected indicator style resource id.
+     */
+    private int mUserSetSelectedIndicatorResId;
+
+    private Drawable mSelectedDrawable;
+    private Drawable mUnselectedDrawable;
+
+    /**
+     *This value is from {@link com.daimajia.slider.library.SliderAdapter} getRealCount() represent
+     *
+     * the indicator count that we should draw.
+     */
+    private int mItemCount = 0;
+
+    private Shape mIndicatorShape = Shape.Oval;
+
+    private IndicatorVisibility mVisibility = IndicatorVisibility.Visible;
+
+    private int mDefaultSelectedColor;
+    private int mDefaultUnSelectedColor;
+
+    private float mDefaultSelectedWidth;
+    private float mDefaultSelectedHeight;
+
+    private float mDefaultUnSelectedWidth;
+    private float mDefaultUnSelectedHeight;
+
+    public enum IndicatorVisibility{
+        Visible,
+        Invisible;
+    };
+
+    private GradientDrawable mUnSelectedGradientDrawable;
+    private GradientDrawable mSelectedGradientDrawable;
+
+    private LayerDrawable mSelectedLayerDrawable;
+    private LayerDrawable mUnSelectedLayerDrawable;
+
+    private float mPadding_left;
+    private float mPadding_right;
+    private float mPadding_top;
+    private float mPadding_bottom;
+
+    private float mSelectedPadding_Left;
+    private float mSelectedPadding_Right;
+    private float mSelectedPadding_Top;
+    private float mSelectedPadding_Bottom;
+
+    private float mUnSelectedPadding_Left;
+    private float mUnSelectedPadding_Right;
+    private float mUnSelectedPadding_Top;
+    private float mUnSelectedPadding_Bottom;
+
+    /**
+     * Put all the indicators into a ArrayList, so we can remove them easily.
+     */
+    private ArrayList<ImageView> mIndicators = new ArrayList<ImageView>();
+
+
+    public PagerIndicator(Context context) {
+        this(context,null);
+    }
+
+    public PagerIndicator(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        mContext = context;
+
+        final TypedArray attributes = context.obtainStyledAttributes(attrs,R.styleable.PagerIndicator,0,0);
+
+        int visibility = attributes.getInt(R.styleable.PagerIndicator_visibility,IndicatorVisibility.Visible.ordinal());
+
+        for(IndicatorVisibility v : IndicatorVisibility.values()){
+            if(v.ordinal() == visibility){
+                mVisibility = v;
+                break;
+            }
+        }
+
+        int shape = attributes.getInt(R.styleable.PagerIndicator_shape, Shape.Oval.ordinal());
+        for(Shape s: Shape.values()){
+            if(s.ordinal() == shape){
+                mIndicatorShape = s;
+                break;
+            }
+        }
+
+        mUserSetSelectedIndicatorResId = attributes.getResourceId(R.styleable.PagerIndicator_selected_drawable,
+                0);
+        mUserSetUnSelectedIndicatorResId = attributes.getResourceId(R.styleable.PagerIndicator_unselected_drawable,
+                0);
+
+        mDefaultSelectedColor = attributes.getColor(R.styleable.PagerIndicator_selected_color, Color.rgb(255, 255, 255));
+        mDefaultUnSelectedColor = attributes.getColor(R.styleable.PagerIndicator_unselected_color, Color.argb(33,255,255,255));
+
+        mDefaultSelectedWidth = attributes.getDimension(R.styleable.PagerIndicator_selected_width,(int)pxFromDp(6));
+        mDefaultSelectedHeight = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_height,(int)pxFromDp(6));
+
+        mDefaultUnSelectedWidth = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_width,(int)pxFromDp(6));
+        mDefaultUnSelectedHeight = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_height,(int)pxFromDp(6));
+
+        mSelectedGradientDrawable = new GradientDrawable();
+        mUnSelectedGradientDrawable = new GradientDrawable();
+
+        mPadding_left = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_padding_left,(int)pxFromDp(3));
+        mPadding_right = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_padding_right,(int)pxFromDp(3));
+        mPadding_top = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_padding_top,(int)pxFromDp(0));
+        mPadding_bottom = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_padding_bottom,(int)pxFromDp(0));
+
+        mSelectedPadding_Left = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_padding_left,(int)mPadding_left);
+        mSelectedPadding_Right = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_padding_right,(int)mPadding_right);
+        mSelectedPadding_Top = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_padding_top,(int)mPadding_top);
+        mSelectedPadding_Bottom = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_padding_bottom,(int)mPadding_bottom);
+
+        mUnSelectedPadding_Left = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_padding_left,(int)mPadding_left);
+        mUnSelectedPadding_Right = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_padding_right,(int)mPadding_right);
+        mUnSelectedPadding_Top = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_padding_top,(int)mPadding_top);
+        mUnSelectedPadding_Bottom = attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_padding_bottom,(int)mPadding_bottom);
+
+        mSelectedLayerDrawable = new LayerDrawable(new Drawable[]{mSelectedGradientDrawable});
+        mUnSelectedLayerDrawable = new LayerDrawable(new Drawable[]{mUnSelectedGradientDrawable});
+
+
+        setIndicatorStyleResource(mUserSetSelectedIndicatorResId,mUserSetUnSelectedIndicatorResId);
+        setDefaultIndicatorShape(mIndicatorShape);
+        setDefaultSelectedIndicatorSize(mDefaultSelectedWidth,mDefaultSelectedHeight,Unit.Px);
+        setDefaultUnselectedIndicatorSize(mDefaultUnSelectedWidth,mDefaultUnSelectedHeight,Unit.Px);
+        setDefaultIndicatorColor(mDefaultSelectedColor, mDefaultUnSelectedColor);
+        setIndicatorVisibility(mVisibility);
+        attributes.recycle();
+    }
+
+    public enum Shape{
+        Oval,Rectangle
+    }
+
+    /**
+     * if you are using the default indicator, this method will help you to set the shape of
+     * indicator, there are two kind of shapes you  can set, oval and rect.
+     * @param shape
+     */
+    public void setDefaultIndicatorShape(Shape shape){
+        if(mUserSetSelectedIndicatorResId == 0){
+            if(shape == Shape.Oval){
+                mSelectedGradientDrawable.setShape(GradientDrawable.OVAL);
+            }else{
+                mSelectedGradientDrawable.setShape(GradientDrawable.RECTANGLE);
+            }
+        }
+        if(mUserSetUnSelectedIndicatorResId == 0){
+            if(shape == Shape.Oval){
+                mUnSelectedGradientDrawable.setShape(GradientDrawable.OVAL);
+            }else{
+                mUnSelectedGradientDrawable.setShape(GradientDrawable.RECTANGLE);
+            }
+        }
+        resetDrawable();
+    }
+
+
+    /**
+     * Set Indicator style.
+     * @param selected page selected drawable
+     * @param unselected page unselected drawable
+     */
+    public void setIndicatorStyleResource(int selected, int unselected){
+        mUserSetSelectedIndicatorResId = selected;
+        mUserSetUnSelectedIndicatorResId = unselected;
+        if(selected == 0){
+            mSelectedDrawable = mSelectedLayerDrawable;
+        }else{
+            mSelectedDrawable = mContext.getResources().getDrawable(mUserSetSelectedIndicatorResId);
+        }
+        if(unselected == 0){
+            mUnselectedDrawable = mUnSelectedLayerDrawable;
+        }else{
+            mUnselectedDrawable = mContext.getResources().getDrawable(mUserSetUnSelectedIndicatorResId);
+        }
+
+        resetDrawable();
+    }
+
+    /**
+     * if you are using the default indicator , this method will help you to set the selected status and
+     * the unselected status color.
+     * @param selectedColor
+     * @param unselectedColor
+     */
+    public void setDefaultIndicatorColor(int selectedColor,int unselectedColor){
+        if(mUserSetSelectedIndicatorResId == 0){
+            mSelectedGradientDrawable.setColor(selectedColor);
+        }
+        if(mUserSetUnSelectedIndicatorResId == 0){
+            mUnSelectedGradientDrawable.setColor(unselectedColor);
+        }
+        resetDrawable();
+    }
+
+    public enum Unit{
+        DP,Px
+    }
+
+    public void setDefaultSelectedIndicatorSize(float width,float height,Unit unit){
+        if(mUserSetSelectedIndicatorResId == 0){
+            float w = width;
+            float h = height;
+            if(unit == Unit.DP){
+                w = pxFromDp(width);
+                h = pxFromDp(height);
+            }
+            mSelectedGradientDrawable.setSize((int) w, (int) h);
+            resetDrawable();
+        }
+    }
+
+    public void setDefaultUnselectedIndicatorSize(float width,float height,Unit unit){
+        if(mUserSetUnSelectedIndicatorResId == 0){
+            float w = width;
+            float h = height;
+            if(unit == Unit.DP){
+                w = pxFromDp(width);
+                h = pxFromDp(height);
+            }
+            mUnSelectedGradientDrawable.setSize((int) w, (int) h);
+            resetDrawable();
+        }
+    }
+
+    public void setDefaultIndicatorSize(float width, float height, Unit unit){
+        setDefaultSelectedIndicatorSize(width,height,unit);
+        setDefaultUnselectedIndicatorSize(width,height,unit);
+    }
+
+    private float dpFromPx(float px)
+    {
+        return px / this.getContext().getResources().getDisplayMetrics().density;
+    }
+
+    private float pxFromDp(float dp)
+    {
+        return dp * this.getContext().getResources().getDisplayMetrics().density;
+    }
+
+    /**
+     * set the visibility of indicator.
+     * @param visibility
+     */
+    public void setIndicatorVisibility(IndicatorVisibility visibility){
+        if(visibility == IndicatorVisibility.Visible){
+            setVisibility(View.VISIBLE);
+        }else{
+            setVisibility(View.INVISIBLE);
+        }
+        resetDrawable();
+    }
+
+    /**
+     * clear self means unregister the dataset observer and remove all the child views(indicators).
+     */
+    public void destroySelf(){
+        if(mPager == null || mPager.getAdapter() == null){
+            return;
+        }
+        InfinitePagerAdapter wrapper = (InfinitePagerAdapter)mPager.getAdapter();
+        PagerAdapter adapter = wrapper.getRealAdapter();
+        if(adapter!=null){
+            adapter.unregisterDataSetObserver(dataChangeObserver);
+        }
+        removeAllViews();
+    }
+
+    /**
+     * bind indicator with viewpagerEx.
+     * @param pager
+     */
+    public void setViewPager(ViewPagerEx pager){
+        if(pager.getAdapter() == null){
+            throw new IllegalStateException("Viewpager does not have adapter instance");
+        }
+        mPager = pager;
+        mPager.addOnPageChangeListener(this);
+        ((InfinitePagerAdapter)mPager.getAdapter()).getRealAdapter().registerDataSetObserver(dataChangeObserver);
+    }
+
+
+    private void resetDrawable(){
+        for(View i : mIndicators){
+            if(mPreviousSelectedIndicator!= null && mPreviousSelectedIndicator.equals(i)){
+                ((ImageView)i).setImageDrawable(mSelectedDrawable);
+            }
+            else{
+                ((ImageView)i).setImageDrawable(mUnselectedDrawable);
+            }
+        }
+    }
+
+    /**
+     * redraw the indicators.
+     */
+    public void redraw(){
+        mItemCount = getShouldDrawCount();
+        mPreviousSelectedIndicator = null;
+        for(View i:mIndicators){
+            removeView(i);
+        }
+
+
+        for(int i =0 ;i< mItemCount; i++){
+            ImageView indicator = new ImageView(mContext);
+            indicator.setImageDrawable(mUnselectedDrawable);
+            indicator.setPadding((int)mUnSelectedPadding_Left,
+                    (int)mUnSelectedPadding_Top,
+                    (int)mUnSelectedPadding_Right,
+                    (int)mUnSelectedPadding_Bottom);
+            addView(indicator);
+            mIndicators.add(indicator);
+        }
+        setItemAsSelected(mPreviousSelectedPosition);
+    }
+
+    /**
+     * since we used a adapter wrapper, so we can't getCount directly from wrapper.
+     * @return
+     */
+    private int getShouldDrawCount(){
+        if(mPager.getAdapter() instanceof InfinitePagerAdapter){
+            return ((InfinitePagerAdapter)mPager.getAdapter()).getRealCount();
+        }else{
+            return mPager.getAdapter().getCount();
+        }
+    }
+
+    private DataSetObserver dataChangeObserver = new DataSetObserver() {
+        @Override
+        public void onChanged() {
+            PagerAdapter adapter = mPager.getAdapter();
+            int count = 0;
+            if(adapter instanceof InfinitePagerAdapter){
+                count = ((InfinitePagerAdapter)adapter).getRealCount();
+            }else{
+                count = adapter.getCount();
+            }
+            if(count > mItemCount){
+                for(int i =0 ; i< count - mItemCount;i++){
+                    ImageView indicator = new ImageView(mContext);
+                    indicator.setImageDrawable(mUnselectedDrawable);
+                    indicator.setPadding((int)mUnSelectedPadding_Left,
+                            (int)mUnSelectedPadding_Top,
+                            (int)mUnSelectedPadding_Right,
+                            (int)mUnSelectedPadding_Bottom);
+                    addView(indicator);
+                    mIndicators.add(indicator);
+                }
+            }else if(count < mItemCount){
+                for(int i = 0; i < mItemCount - count;i++){
+                    removeView(mIndicators.get(0));
+                    mIndicators.remove(0);
+                }
+            }
+            mItemCount = count;
+            mPager.setCurrentItem(mItemCount*20 + mPager.getCurrentItem());
+        }
+
+        @Override
+        public void onInvalidated() {
+            super.onInvalidated();
+            redraw();
+        }
+    };
+
+    private void setItemAsSelected(int position){
+        if(mPreviousSelectedIndicator != null){
+            mPreviousSelectedIndicator.setImageDrawable(mUnselectedDrawable);
+            mPreviousSelectedIndicator.setPadding(
+                    (int)mUnSelectedPadding_Left,
+                    (int)mUnSelectedPadding_Top,
+                    (int)mUnSelectedPadding_Right,
+                    (int)mUnSelectedPadding_Bottom
+            );
+        }
+        ImageView currentSelected = (ImageView)getChildAt(position + 1);
+        if(currentSelected != null){
+            currentSelected.setImageDrawable(mSelectedDrawable);
+            currentSelected.setPadding(
+                    (int)mSelectedPadding_Left,
+                    (int)mSelectedPadding_Top,
+                    (int)mSelectedPadding_Right,
+                    (int)mSelectedPadding_Bottom
+            );
+            mPreviousSelectedIndicator = currentSelected;
+        }
+        mPreviousSelectedPosition = position;
+    }
+
+    @Override
+    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+    }
+
+    public IndicatorVisibility getIndicatorVisibility(){
+        return mVisibility;
+    }
+
+    @Override
+    public void onPageSelected(int position) {
+         if(mItemCount == 0){
+            return;
+        }
+        setItemAsSelected(position-1);
+    }
+    @Override
+    public void onPageScrollStateChanged(int state) {
+    }
+
+    public int getSelectedIndicatorResId(){
+        return mUserSetSelectedIndicatorResId;
+    }
+
+    public int getUnSelectedIndicatorResId(){
+        return mUserSetUnSelectedIndicatorResId;
+    }
+
+}
Index: library/src/main/java/com/daimajia/slider/library/Tricks/InfinitePagerAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Tricks/InfinitePagerAdapter.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Tricks/InfinitePagerAdapter.java	(revision )
@@ -0,0 +1,108 @@
+package com.daimajia.slider.library.Tricks;
+
+import android.os.Parcelable;
+import android.support.v4.view.PagerAdapter;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.daimajia.slider.library.SliderAdapter;
+
+/**
+ * A PagerAdapter that wraps around another PagerAdapter to handle paging wrap-around.
+ * Thanks to: https://github.com/antonyt/InfiniteViewPager
+ */
+public class InfinitePagerAdapter extends PagerAdapter {
+
+    private static final String TAG = "InfinitePagerAdapter";
+    private static final boolean DEBUG = false;
+
+    private SliderAdapter adapter;
+
+    public InfinitePagerAdapter(SliderAdapter adapter) {
+        this.adapter = adapter;
+    }
+
+    public SliderAdapter getRealAdapter(){
+        return this.adapter;
+    }
+
+    @Override
+    public int getCount() {
+        // warning: scrolling to very high values (1,000,000+) results in
+        // strange drawing behaviour
+        return Integer.MAX_VALUE;
+    }
+
+    /**
+     * @return the {@link #getCount()} result of the wrapped adapter
+     */
+    public int getRealCount() {
+        return adapter.getCount();
+    }
+
+    @Override
+    public Object instantiateItem(ViewGroup container, int position) {
+        if(getRealCount() == 0){
+            return null;
+        }
+        int virtualPosition = position % getRealCount();
+        debug("instantiateItem: real position: " + position);
+        debug("instantiateItem: virtual position: " + virtualPosition);
+
+        // only expose virtual position to the inner adapter
+        return adapter.instantiateItem(container, virtualPosition);
+    }
+
+    @Override
+    public void destroyItem(ViewGroup container, int position, Object object) {
+        if(getRealCount() == 0){
+            return;
+        }
+        int virtualPosition = position % getRealCount();
+        debug("destroyItem: real position: " + position);
+        debug("destroyItem: virtual position: " + virtualPosition);
+
+        // only expose virtual position to the inner adapter
+        adapter.destroyItem(container, virtualPosition, object);
+    }
+
+    /*
+     * Delegate rest of methods directly to the inner adapter.
+     */
+
+    @Override
+    public void finishUpdate(ViewGroup container) {
+        adapter.finishUpdate(container);
+    }
+
+    @Override
+    public boolean isViewFromObject(View view, Object object) {
+        return adapter.isViewFromObject(view, object);
+    }
+
+    @Override
+    public void restoreState(Parcelable bundle, ClassLoader classLoader) {
+        adapter.restoreState(bundle, classLoader);
+    }
+
+    @Override
+    public Parcelable saveState() {
+        return adapter.saveState();
+    }
+
+    @Override
+    public void startUpdate(ViewGroup container) {
+        adapter.startUpdate(container);
+    }
+
+    /*
+     * End delegation
+     */
+
+    private void debug(String message) {
+        if (DEBUG) {
+            Log.d(TAG, message);
+        }
+    }
+}
\ No newline at end of file
Index: .travis.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .travis.yml	(revision )
+++ .travis.yml	(revision )
@@ -0,0 +1,25 @@
+language: android
+android:
+  components:
+    # Uncomment the lines below if you want to
+    # use the latest revision of Android SDK Tools
+    # - platform-tools
+    # - tools
+
+    # The BuildTools version used by your project
+    - build-tools-22.0.1
+
+    # The SDK version used to compile your project
+    - android-22
+
+    # Additional components
+    - extra-google-google_play_services
+    - extra-google-m2repository
+    - extra-android-m2repository
+    - addon-google_apis-google-19
+
+    # Specify at least one system image,
+    # if you need to run emulator(s) during your tests
+    - sys-img-armeabi-v7a-android-19
+    - sys-img-x86-android-17
+script: ./gradlew assembleDebug
Index: library/src/main/res/layout/render_type_text.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/res/layout/render_type_text.xml	(revision )
+++ library/src/main/res/layout/render_type_text.xml	(revision )
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent" android:layout_height="match_parent">
+    <ImageView
+        android:id="@+id/daimajia_slider_image"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
+    <ProgressBar
+        android:id="@+id/loading_bar"
+        android:layout_centerInParent="true"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content" />
+    <LinearLayout
+        android:id="@+id/description_layout"
+        android:layout_alignParentBottom="true"
+        android:minHeight="30dp"
+        android:background="#77000000"
+        android:layout_width="match_parent"
+        android:orientation="vertical"
+        android:gravity="center_vertical"
+        android:paddingLeft="10dp"
+        android:layout_height="wrap_content">
+            <TextView
+                android:id="@+id/description"
+                android:textColor="#ffffff"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content" />
+        </LinearLayout>
+</RelativeLayout>
\ No newline at end of file
Index: settings.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- settings.gradle	(revision )
+++ settings.gradle	(revision )
@@ -0,0 +1,1 @@
+include ':demo', ':library'
Index: demo/src/main/java/com/daimajia/slider/demo/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/java/com/daimajia/slider/demo/MainActivity.java	(revision )
+++ demo/src/main/java/com/daimajia/slider/demo/MainActivity.java	(revision )
@@ -0,0 +1,133 @@
+package com.daimajia.slider.demo;
+
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.v7.app.ActionBarActivity;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.AdapterView;
+import android.widget.ListView;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.daimajia.slider.library.Animations.DescriptionAnimation;
+import com.daimajia.slider.library.Indicators.PagerIndicator;
+import com.daimajia.slider.library.SliderLayout;
+import com.daimajia.slider.library.SliderTypes.BaseSliderView;
+import com.daimajia.slider.library.SliderTypes.TextSliderView;
+import com.daimajia.slider.library.Tricks.ViewPagerEx;
+
+import java.util.HashMap;
+
+
+public class MainActivity extends ActionBarActivity implements BaseSliderView.OnSliderClickListener, ViewPagerEx.OnPageChangeListener{
+
+    private SliderLayout mDemoSlider;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        mDemoSlider = (SliderLayout)findViewById(R.id.slider);
+
+        HashMap<String,String> url_maps = new HashMap<String, String>();
+        url_maps.put("Hannibal", "http://static2.hypable.com/wp-content/uploads/2013/12/hannibal-season-2-release-date.jpg");
+        url_maps.put("Big Bang Theory", "http://tvfiles.alphacoders.com/100/hdclearart-10.png");
+        url_maps.put("House of Cards", "http://cdn3.nflximg.net/images/3093/2043093.jpg");
+        url_maps.put("Game of Thrones", "http://images.boomsbeat.com/data/images/full/19640/game-of-thrones-season-4-jpg.jpg");
+
+        HashMap<String,Integer> file_maps = new HashMap<String, Integer>();
+        file_maps.put("Hannibal",R.drawable.hannibal);
+        file_maps.put("Big Bang Theory",R.drawable.bigbang);
+        file_maps.put("House of Cards",R.drawable.house);
+        file_maps.put("Game of Thrones", R.drawable.game_of_thrones);
+
+        for(String name : file_maps.keySet()){
+            TextSliderView textSliderView = new TextSliderView(this);
+            // initialize a SliderLayout
+            textSliderView
+                    .description(name)
+                    .image(file_maps.get(name))
+                    .setScaleType(BaseSliderView.ScaleType.Fit)
+                    .setOnSliderClickListener(this);
+
+            //add your extra information
+            textSliderView.bundle(new Bundle());
+            textSliderView.getBundle()
+                        .putString("extra",name);
+
+           mDemoSlider.addSlider(textSliderView);
+        }
+        mDemoSlider.setPresetTransformer(SliderLayout.Transformer.Accordion);
+        mDemoSlider.setPresetIndicator(SliderLayout.PresetIndicators.Center_Bottom);
+        mDemoSlider.setCustomAnimation(new DescriptionAnimation());
+        mDemoSlider.setDuration(4000);
+        mDemoSlider.addOnPageChangeListener(this);
+        ListView l = (ListView)findViewById(R.id.transformers);
+        l.setAdapter(new TransformerAdapter(this));
+        l.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                mDemoSlider.setPresetTransformer(((TextView) view).getText().toString());
+                Toast.makeText(MainActivity.this, ((TextView) view).getText().toString(), Toast.LENGTH_SHORT).show();
+            }
+        });
+
+
+    }
+
+    @Override
+    protected void onStop() {
+        // To prevent a memory leak on rotation, make sure to call stopAutoCycle() on the slider before activity or fragment is destroyed
+        mDemoSlider.stopAutoCycle();
+        super.onStop();
+    }
+
+    @Override
+    public void onSliderClick(BaseSliderView slider) {
+        Toast.makeText(this,slider.getBundle().get("extra") + "",Toast.LENGTH_SHORT).show();
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        MenuInflater menuInflater = getMenuInflater();
+        menuInflater.inflate(R.menu.main,menu);
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()){
+            case R.id.action_custom_indicator:
+                mDemoSlider.setCustomIndicator((PagerIndicator) findViewById(R.id.custom_indicator));
+                break;
+            case R.id.action_custom_child_animation:
+                mDemoSlider.setCustomAnimation(new ChildAnimationExample());
+                break;
+            case R.id.action_restore_default:
+                mDemoSlider.setPresetIndicator(SliderLayout.PresetIndicators.Center_Bottom);
+                mDemoSlider.setCustomAnimation(new DescriptionAnimation());
+                break;
+            case R.id.action_github:
+                Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/daimajia/AndroidImageSlider"));
+                startActivity(browserIntent);
+                break;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {}
+
+    @Override
+    public void onPageSelected(int position) {
+        Log.d("Slider Demo", "Page Changed: " + position);
+    }
+
+    @Override
+    public void onPageScrollStateChanged(int state) {}
+}
Index: library/src/main/java/com/daimajia/slider/library/Transformers/CubeInTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/CubeInTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/CubeInTransformer.java	(revision )
@@ -0,0 +1,22 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class CubeInTransformer extends BaseTransformer {
+
+	@Override
+	protected void onTransform(View view, float position) {
+		// Rotate the fragment on the left or right edge
+        ViewHelper.setPivotX(view,position > 0 ? 0 : view.getWidth());
+        ViewHelper.setPivotY(view,0);
+        ViewHelper.setRotation(view,-90f * position);
+	}
+
+	@Override
+	public boolean isPagingEnabled() {
+		return true;
+	}
+
+}
Index: library/src/main/java/com/daimajia/slider/library/Transformers/RotateUpTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/RotateUpTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/RotateUpTransformer.java	(revision )
@@ -0,0 +1,27 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class RotateUpTransformer extends BaseTransformer {
+
+	private static final float ROT_MOD = -15f;
+
+	@Override
+	protected void onTransform(View view, float position) {
+		final float width = view.getWidth();
+		final float rotation = ROT_MOD * position;
+
+		ViewHelper.setPivotX(view,width * 0.5f);
+        ViewHelper.setPivotY(view,0f);
+        ViewHelper.setTranslationX(view,0f);
+        ViewHelper.setRotation(view,rotation);
+	}
+	
+	@Override
+	protected boolean isPagingEnabled() {
+		return true;
+	}
+
+}
Index: library/src/main/java/com/daimajia/slider/library/Transformers/DepthPageTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/DepthPageTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/DepthPageTransformer.java	(revision )
@@ -0,0 +1,32 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class DepthPageTransformer extends BaseTransformer {
+
+	private static final float MIN_SCALE = 0.75f;
+
+	@Override
+	protected void onTransform(View view, float position) {
+		if (position <= 0f) {
+            ViewHelper.setTranslationX(view,0f);
+            ViewHelper.setScaleX(view,1f);
+            ViewHelper.setScaleY(view,1f);
+		} else if (position <= 1f) {
+			final float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position));
+            ViewHelper.setAlpha(view,1-position);
+            ViewHelper.setPivotY(view,0.5f * view.getHeight());
+            ViewHelper.setTranslationX(view,view.getWidth() * - position);
+            ViewHelper.setScaleX(view,scaleFactor);
+            ViewHelper.setScaleY(view,scaleFactor);
+		}
+	}
+
+	@Override
+	protected boolean isPagingEnabled() {
+		return true;
+	}
+
+}
Index: library/src/main/java/com/daimajia/slider/library/Tricks/InfiniteViewPager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Tricks/InfiniteViewPager.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Tricks/InfiniteViewPager.java	(revision )
@@ -0,0 +1,27 @@
+package com.daimajia.slider.library.Tricks;
+
+import android.content.Context;
+import android.support.v4.view.PagerAdapter;
+import android.support.v4.view.ViewPager;
+import android.util.AttributeSet;
+
+/**
+ * A {@link ViewPager} that allows pseudo-infinite paging with a wrap-around effect. Should be used with an {@link
+ * InfinitePagerAdapter}.
+ */
+public class InfiniteViewPager extends ViewPagerEx {
+
+    public InfiniteViewPager(Context context) {
+        super(context);
+    }
+
+    public InfiniteViewPager(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    public void setAdapter(PagerAdapter adapter) {
+        super.setAdapter(adapter);
+    }
+
+}
\ No newline at end of file
Index: demo/src/main/java/com/daimajia/slider/demo/TransformerAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/java/com/daimajia/slider/demo/TransformerAdapter.java	(revision )
+++ demo/src/main/java/com/daimajia/slider/demo/TransformerAdapter.java	(revision )
@@ -0,0 +1,42 @@
+package com.daimajia.slider.demo;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.TextView;
+
+import com.daimajia.slider.library.SliderLayout;
+
+/**
+ * Created by daimajia on 14-5-29.
+ */
+public class TransformerAdapter extends BaseAdapter{
+    private Context mContext;
+    public TransformerAdapter(Context context) {
+        mContext = context;
+    }
+
+    @Override
+    public int getCount() {
+        return SliderLayout.Transformer.values().length;
+    }
+
+    @Override
+    public Object getItem(int position) {
+        return SliderLayout.Transformer.values()[position].toString();
+    }
+
+    @Override
+    public long getItemId(int position) {
+        return position;
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        TextView t = (TextView)LayoutInflater.from(mContext).inflate(R.layout.item,null);
+        t.setText(getItem(position).toString());
+        return t;
+    }
+}
Index: demo/src/main/res/values/styles.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/res/values/styles.xml	(revision )
+++ demo/src/main/res/values/styles.xml	(revision )
@@ -0,0 +1,8 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
Index: library/src/main/java/com/daimajia/slider/library/Transformers/FlipHorizontalTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/FlipHorizontalTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/FlipHorizontalTransformer.java	(revision )
@@ -0,0 +1,18 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class FlipHorizontalTransformer extends BaseTransformer {
+
+	@Override
+	protected void onTransform(View view, float position) {
+		final float rotation = 180f * position;
+        ViewHelper.setAlpha(view,rotation > 90f || rotation < -90f ? 0 : 1);
+        ViewHelper.setPivotY(view,view.getHeight()*0.5f);
+		ViewHelper.setPivotX(view,view.getWidth() * 0.5f);
+		ViewHelper.setRotationY(view,rotation);
+	}
+
+}
Index: library/src/main/java/com/daimajia/slider/library/SliderTypes/BaseSliderView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/SliderTypes/BaseSliderView.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/SliderTypes/BaseSliderView.java	(revision )
@@ -0,0 +1,328 @@
+package com.daimajia.slider.library.SliderTypes;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.daimajia.slider.library.R;
+import com.squareup.picasso.Callback;
+import com.squareup.picasso.Picasso;
+import com.squareup.picasso.RequestCreator;
+
+import java.io.File;
+
+/**
+ * When you want to make your own slider view, you must extends from this class.
+ * BaseSliderView provides some useful methods.
+ * I provide two example: {@link com.daimajia.slider.library.SliderTypes.DefaultSliderView} and
+ * {@link com.daimajia.slider.library.SliderTypes.TextSliderView}
+ * if you want to show progressbar, you just need to set a progressbar id as @+id/loading_bar.
+ */
+public abstract class BaseSliderView {
+
+    protected Context mContext;
+
+    private Bundle mBundle;
+
+    /**
+     * Error place holder image.
+     */
+    private int mErrorPlaceHolderRes;
+
+    /**
+     * Empty imageView placeholder.
+     */
+    private int mEmptyPlaceHolderRes;
+
+    private String mUrl;
+    private File mFile;
+    private int mRes;
+
+    protected OnSliderClickListener mOnSliderClickListener;
+
+    private boolean mErrorDisappear;
+
+    private ImageLoadListener mLoadListener;
+
+    private String mDescription;
+
+    private Picasso mPicasso;
+
+    /**
+     * Scale type of the image.
+     */
+    private ScaleType mScaleType = ScaleType.Fit;
+
+    public enum ScaleType{
+        CenterCrop, CenterInside, Fit, FitCenterCrop
+    }
+
+    protected BaseSliderView(Context context) {
+        mContext = context;
+    }
+
+    /**
+     * the placeholder image when loading image from url or file.
+     * @param resId Image resource id
+     * @return
+     */
+    public BaseSliderView empty(int resId){
+        mEmptyPlaceHolderRes = resId;
+        return this;
+    }
+
+    /**
+     * determine whether remove the image which failed to download or load from file
+     * @param disappear
+     * @return
+     */
+    public BaseSliderView errorDisappear(boolean disappear){
+        mErrorDisappear = disappear;
+        return this;
+    }
+
+    /**
+     * if you set errorDisappear false, this will set a error placeholder image.
+     * @param resId image resource id
+     * @return
+     */
+    public BaseSliderView error(int resId){
+        mErrorPlaceHolderRes = resId;
+        return this;
+    }
+
+    /**
+     * the description of a slider image.
+     * @param description
+     * @return
+     */
+    public BaseSliderView description(String description){
+        mDescription = description;
+        return this;
+    }
+
+    /**
+     * set a url as a image that preparing to load
+     * @param url
+     * @return
+     */
+    public BaseSliderView image(String url){
+        if(mFile != null || mRes != 0){
+            throw new IllegalStateException("Call multi image function," +
+                    "you only have permission to call it once");
+        }
+        mUrl = url;
+        return this;
+    }
+
+    /**
+     * set a file as a image that will to load
+     * @param file
+     * @return
+     */
+    public BaseSliderView image(File file){
+        if(mUrl != null || mRes != 0){
+            throw new IllegalStateException("Call multi image function," +
+                    "you only have permission to call it once");
+        }
+        mFile = file;
+        return this;
+    }
+
+    public BaseSliderView image(int res){
+        if(mUrl != null || mFile != null){
+            throw new IllegalStateException("Call multi image function," +
+                    "you only have permission to call it once");
+        }
+        mRes = res;
+        return this;
+    }
+
+    /**
+     * lets users add a bundle of additional information
+     * @param bundle
+     * @return
+     */
+    public BaseSliderView bundle(Bundle bundle){
+        mBundle = bundle;
+        return this;
+    }
+
+    public String getUrl(){
+        return mUrl;
+    }
+
+    public boolean isErrorDisappear(){
+        return mErrorDisappear;
+    }
+
+    public int getEmpty(){
+        return mEmptyPlaceHolderRes;
+    }
+
+    public int getError(){
+        return mErrorPlaceHolderRes;
+    }
+
+    public String getDescription(){
+        return mDescription;
+    }
+
+    public Context getContext(){
+        return mContext;
+    }
+
+    /**
+     * set a slider image click listener
+     * @param l
+     * @return
+     */
+    public BaseSliderView setOnSliderClickListener(OnSliderClickListener l){
+        mOnSliderClickListener = l;
+        return this;
+    }
+
+    /**
+     * When you want to implement your own slider view, please call this method in the end in `getView()` method
+     * @param v the whole view
+     * @param targetImageView where to place image
+     */
+    protected void bindEventAndShow(final View v, ImageView targetImageView){
+        final BaseSliderView me = this;
+
+        v.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+            if(mOnSliderClickListener != null){
+                mOnSliderClickListener.onSliderClick(me);
+            }
+            }
+        });
+
+        if (targetImageView == null)
+            return;
+
+        if (mLoadListener != null) {
+            mLoadListener.onStart(me);
+        }
+
+        Picasso p = (mPicasso != null) ? mPicasso : Picasso.with(mContext);
+        RequestCreator rq = null;
+        if(mUrl!=null){
+            rq = p.load(mUrl);
+        }else if(mFile != null){
+            rq = p.load(mFile);
+        }else if(mRes != 0){
+            rq = p.load(mRes);
+        }else{
+            return;
+        }
+
+        if(rq == null){
+            return;
+        }
+
+        if(getEmpty() != 0){
+            rq.placeholder(getEmpty());
+        }
+
+        if(getError() != 0){
+            rq.error(getError());
+        }
+
+        switch (mScaleType){
+            case Fit:
+                rq.fit();
+                break;
+            case CenterCrop:
+                rq.fit().centerCrop();
+                break;
+            case CenterInside:
+                rq.fit().centerInside();
+                break;
+        }
+
+        rq.into(targetImageView,new Callback() {
+            @Override
+            public void onSuccess() {
+                if(v.findViewById(R.id.loading_bar) != null){
+                    v.findViewById(R.id.loading_bar).setVisibility(View.INVISIBLE);
+                }
+            }
+
+            @Override
+            public void onError() {
+                if(mLoadListener != null){
+                    mLoadListener.onEnd(false,me);
+                }
+                if(v.findViewById(R.id.loading_bar) != null){
+                    v.findViewById(R.id.loading_bar).setVisibility(View.INVISIBLE);
+                }
+            }
+        });
+   }
+
+
+
+    public BaseSliderView setScaleType(ScaleType type){
+        mScaleType = type;
+        return this;
+    }
+
+    public ScaleType getScaleType(){
+        return mScaleType;
+    }
+
+    /**
+     * the extended class have to implement getView(), which is called by the adapter,
+     * every extended class response to render their own view.
+     * @return
+     */
+    public abstract View getView();
+
+    /**
+     * set a listener to get a message , if load error.
+     * @param l
+     */
+    public void setOnImageLoadListener(ImageLoadListener l){
+        mLoadListener = l;
+    }
+
+    public interface OnSliderClickListener {
+        public void onSliderClick(BaseSliderView slider);
+    }
+
+    /**
+     * when you have some extra information, please put it in this bundle.
+     * @return
+     */
+    public Bundle getBundle(){
+        return mBundle;
+    }
+
+    public interface ImageLoadListener{
+        public void onStart(BaseSliderView target);
+        public void onEnd(boolean result,BaseSliderView target);
+    }
+
+    /**
+     * Get the last instance set via setPicasso(), or null if no user provided instance was set
+     *
+     * @return The current user-provided Picasso instance, or null if none
+     */
+    public Picasso getPicasso() {
+        return mPicasso;
+    }
+
+    /**
+     * Provide a Picasso instance to use when loading pictures, this is useful if you have a
+     * particular HTTP cache you would like to share.
+     *
+     * @param picasso The Picasso instance to use, may be null to let the system use the default
+     *                instance
+     */
+    public void setPicasso(Picasso picasso) {
+        mPicasso = picasso;
+    }
+}
Index: library/src/main/java/com/daimajia/slider/library/Transformers/BaseTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/BaseTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/BaseTransformer.java	(revision )
@@ -0,0 +1,151 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.daimajia.slider.library.Animations.BaseAnimationInterface;
+import com.daimajia.slider.library.Tricks.ViewPagerEx;
+import com.nineoldandroids.view.ViewHelper;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+/**
+ * This is all transformers father.
+ *
+ * BaseTransformer implement {@link com.daimajia.slider.library.Tricks.ViewPagerEx.PageTransformer}
+ * which is just same as {@link android.support.v4.view.ViewPager.PageTransformer}.
+ *
+ * After you call setPageTransformer(), transformPage() will be called by {@link com.daimajia.slider.library.Tricks.ViewPagerEx}
+ * when your slider are animating.
+ *
+ * In onPreTransform() function, that will make {@link com.daimajia.slider.library.Animations.BaseAnimationInterface}
+ * work.
+ *
+ * if you want to make an acceptable transformer, please do not forget to extend from this class.
+ */
+public abstract class BaseTransformer implements ViewPagerEx.PageTransformer {
+
+    private BaseAnimationInterface mCustomAnimationInterface;
+
+    /**
+     * Called each {@link #transformPage(View, float)}.
+     *
+     * @param view
+     * @param position
+     */
+    protected abstract void onTransform(View view, float position);
+
+    private HashMap<View,ArrayList<Float>> h = new HashMap<View, ArrayList<Float>>();
+
+    @Override
+    public void transformPage(View view, float position) {
+        onPreTransform(view, position);
+        onTransform(view, position);
+        onPostTransform(view, position);
+    }
+
+    /**
+     * If the position offset of a fragment is less than negative one or greater than one, returning true will set the
+     * visibility of the fragment to {@link View#GONE}. Returning false will force the fragment to {@link View#VISIBLE}.
+     *
+     * @return
+     */
+    protected boolean hideOffscreenPages() {
+        return true;
+    }
+
+    /**
+     * Indicates if the default animations of the view pager should be used.
+     *
+     * @return
+     */
+    protected boolean isPagingEnabled() {
+        return false;
+    }
+
+    /**
+     * Called each {@link #transformPage(View, float)} before {{@link #onTransform(View, float)} is called.
+     *
+     * @param view
+     * @param position
+     */
+    protected void onPreTransform(View view, float position) {
+        final float width = view.getWidth();
+
+        ViewHelper.setRotationX(view,0);
+        ViewHelper.setRotationY(view,0);
+        ViewHelper.setRotation(view,0);
+        ViewHelper.setScaleX(view,1);
+        ViewHelper.setScaleY(view,1);
+        ViewHelper.setPivotX(view,0);
+        ViewHelper.setPivotY(view,0);
+        ViewHelper.setTranslationY(view,0);
+        ViewHelper.setTranslationX(view,isPagingEnabled() ? 0f : -width * position);
+
+        if (hideOffscreenPages()) {
+            ViewHelper.setAlpha(view,position <= -1f || position >= 1f ? 0f : 1f);
+        } else {
+            ViewHelper.setAlpha(view,1f);
+        }
+        if(mCustomAnimationInterface != null){
+            if(h.containsKey(view) == false || h.get(view).size() == 1){
+                if(position > -1 && position < 1){
+                    if(h.get(view) == null){
+                        h.put(view,new ArrayList<Float>());
+                    }
+                    h.get(view).add(position);
+                    if(h.get(view).size() == 2){
+                        float zero = h.get(view).get(0);
+                        float cha = h.get(view).get(1) - h.get(view).get(0);
+                        if(zero > 0){
+                            if(cha > -1 && cha < 0){
+                                //in
+                                mCustomAnimationInterface.onPrepareNextItemShowInScreen(view);
+                            }else{
+                                //out
+                                mCustomAnimationInterface.onPrepareCurrentItemLeaveScreen(view);
+                            }
+                        }else{
+                            if(cha > -1 && cha < 0){
+                                //out
+                                mCustomAnimationInterface.onPrepareCurrentItemLeaveScreen(view);
+                            }else{
+                                //in
+                                mCustomAnimationInterface.onPrepareNextItemShowInScreen(view);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    boolean isApp,isDis;
+    /**
+     * Called each {@link #transformPage(View, float)} call after {@link #onTransform(View, float)} is finished.
+     *
+     * @param view
+     * @param position
+     */
+    protected void onPostTransform(View view, float position) {
+        if(mCustomAnimationInterface != null){
+            if(position == -1 || position == 1){
+                mCustomAnimationInterface.onCurrentItemDisappear(view);
+                isApp = true;
+            }else if(position == 0){
+                mCustomAnimationInterface.onNextItemAppear(view);
+                isDis = true;
+            }
+            if(isApp && isDis){
+                h.clear();
+                isApp = false;
+                isDis = false;
+            }
+        }
+    }
+
+
+    public void setCustomAnimationInterface(BaseAnimationInterface animationInterface){
+        mCustomAnimationInterface = animationInterface;
+    }
+
+}
\ No newline at end of file
Index: demo/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/.gitignore	(revision )
+++ demo/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: library/src/main/java/com/daimajia/slider/library/SliderLayout.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/SliderLayout.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/SliderLayout.java	(revision )
@@ -0,0 +1,702 @@
+package com.daimajia.slider.library;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.os.Message;
+import android.support.v4.view.PagerAdapter;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.animation.Interpolator;
+import android.widget.RelativeLayout;
+
+import com.daimajia.slider.library.Animations.BaseAnimationInterface;
+import com.daimajia.slider.library.Indicators.PagerIndicator;
+import com.daimajia.slider.library.SliderTypes.BaseSliderView;
+import com.daimajia.slider.library.Transformers.AccordionTransformer;
+import com.daimajia.slider.library.Transformers.BackgroundToForegroundTransformer;
+import com.daimajia.slider.library.Transformers.BaseTransformer;
+import com.daimajia.slider.library.Transformers.CubeInTransformer;
+import com.daimajia.slider.library.Transformers.DefaultTransformer;
+import com.daimajia.slider.library.Transformers.DepthPageTransformer;
+import com.daimajia.slider.library.Transformers.FadeTransformer;
+import com.daimajia.slider.library.Transformers.FlipHorizontalTransformer;
+import com.daimajia.slider.library.Transformers.FlipPageViewTransformer;
+import com.daimajia.slider.library.Transformers.ForegroundToBackgroundTransformer;
+import com.daimajia.slider.library.Transformers.RotateDownTransformer;
+import com.daimajia.slider.library.Transformers.RotateUpTransformer;
+import com.daimajia.slider.library.Transformers.StackTransformer;
+import com.daimajia.slider.library.Transformers.TabletTransformer;
+import com.daimajia.slider.library.Transformers.ZoomInTransformer;
+import com.daimajia.slider.library.Transformers.ZoomOutSlideTransformer;
+import com.daimajia.slider.library.Transformers.ZoomOutTransformer;
+import com.daimajia.slider.library.Tricks.FixedSpeedScroller;
+import com.daimajia.slider.library.Tricks.InfinitePagerAdapter;
+import com.daimajia.slider.library.Tricks.InfiniteViewPager;
+import com.daimajia.slider.library.Tricks.ViewPagerEx;
+
+import java.lang.reflect.Field;
+import java.util.Timer;
+import java.util.TimerTask;
+
+/**
+ * SliderLayout is compound layout. This is combined with {@link com.daimajia.slider.library.Indicators.PagerIndicator}
+ * and {@link com.daimajia.slider.library.Tricks.ViewPagerEx} .
+ *
+ * There is some properties you can set in XML:
+ *
+ * indicator_visibility
+ *      visible
+ *      invisible
+ *
+ * indicator_shape
+ *      oval
+ *      rect
+ *
+ * indicator_selected_color
+ *
+ * indicator_unselected_color
+ *
+ * indicator_selected_drawable
+ *
+ * indicator_unselected_drawable
+ *
+ * pager_animation
+ *      Default
+ *      Accordion
+ *      Background2Foreground
+ *      CubeIn
+ *      DepthPage
+ *      Fade
+ *      FlipHorizontal
+ *      FlipPage
+ *      Foreground2Background
+ *      RotateDown
+ *      RotateUp
+ *      Stack
+ *      Tablet
+ *      ZoomIn
+ *      ZoomOutSlide
+ *      ZoomOut
+ *
+ * pager_animation_span
+ *
+ *
+ */
+public class SliderLayout extends RelativeLayout{
+
+    private Context mContext;
+    /**
+     * InfiniteViewPager is extended from ViewPagerEx. As the name says, it can scroll without bounder.
+     */
+    private InfiniteViewPager mViewPager;
+
+    /**
+     * InfiniteViewPager adapter.
+     */
+    private SliderAdapter mSliderAdapter;
+
+    /**
+     * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} indicator.
+     */
+    private PagerIndicator mIndicator;
+
+
+    /**
+     * A timer and a TimerTask using to cycle the {@link com.daimajia.slider.library.Tricks.ViewPagerEx}.
+     */
+    private Timer mCycleTimer;
+    private TimerTask mCycleTask;
+
+    /**
+     * For resuming the cycle, after user touch or click the {@link com.daimajia.slider.library.Tricks.ViewPagerEx}.
+     */
+    private Timer mResumingTimer;
+    private TimerTask mResumingTask;
+
+    /**
+     * If {@link com.daimajia.slider.library.Tricks.ViewPagerEx} is Cycling
+     */
+    private boolean mCycling;
+
+    /**
+     * Determine if auto recover after user touch the {@link com.daimajia.slider.library.Tricks.ViewPagerEx}
+     */
+    private boolean mAutoRecover = true;
+
+    private int mTransformerId;
+
+    /**
+     * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} transformer time span.
+     */
+    private int mTransformerSpan = 1100;
+
+    private boolean mAutoCycle;
+
+    /**
+     * the duration between animation.
+     */
+    private long mSliderDuration = 4000;
+
+    /**
+     * Visibility of {@link com.daimajia.slider.library.Indicators.PagerIndicator}
+     */
+    private PagerIndicator.IndicatorVisibility mIndicatorVisibility = PagerIndicator.IndicatorVisibility.Visible;
+
+    /**
+     * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} 's transformer
+     */
+    private BaseTransformer mViewPagerTransformer;
+
+    /**
+     * @see com.daimajia.slider.library.Animations.BaseAnimationInterface
+     */
+    private BaseAnimationInterface mCustomAnimation;
+
+    /**
+     * {@link com.daimajia.slider.library.Indicators.PagerIndicator} shape, rect or oval.
+     */
+
+    public SliderLayout(Context context) {
+        this(context,null);
+    }
+
+    public SliderLayout(Context context, AttributeSet attrs) {
+        this(context,attrs,R.attr.SliderStyle);
+    }
+
+    public SliderLayout(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        mContext = context;
+        LayoutInflater.from(context).inflate(R.layout.slider_layout, this, true);
+
+        final TypedArray attributes = context.getTheme().obtainStyledAttributes(attrs,R.styleable.SliderLayout,
+                defStyle,0);
+
+        mTransformerSpan = attributes.getInteger(R.styleable.SliderLayout_pager_animation_span, 1100);
+        mTransformerId = attributes.getInt(R.styleable.SliderLayout_pager_animation, Transformer.Default.ordinal());
+        mAutoCycle = attributes.getBoolean(R.styleable.SliderLayout_auto_cycle,true);
+        int visibility = attributes.getInt(R.styleable.SliderLayout_indicator_visibility,0);
+        for(PagerIndicator.IndicatorVisibility v: PagerIndicator.IndicatorVisibility.values()){
+            if(v.ordinal() == visibility){
+                mIndicatorVisibility = v;
+                break;
+            }
+        }
+        mSliderAdapter = new SliderAdapter(mContext);
+        PagerAdapter wrappedAdapter = new InfinitePagerAdapter(mSliderAdapter);
+
+        mViewPager = (InfiniteViewPager)findViewById(R.id.daimajia_slider_viewpager);
+        mViewPager.setAdapter(wrappedAdapter);
+
+        mViewPager.setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                int action = event.getAction();
+                switch (action) {
+                     case MotionEvent.ACTION_UP:
+                        recoverCycle();
+                        break;
+                }
+                return false;
+            }
+        });
+
+        attributes.recycle();
+        setPresetIndicator(PresetIndicators.Center_Bottom);
+        setPresetTransformer(mTransformerId);
+        setSliderTransformDuration(mTransformerSpan,null);
+        setIndicatorVisibility(mIndicatorVisibility);
+        if(mAutoCycle){
+            startAutoCycle();
+        }
+    }
+
+    public void addOnPageChangeListener(ViewPagerEx.OnPageChangeListener onPageChangeListener){
+        if(onPageChangeListener != null){
+            mViewPager.addOnPageChangeListener(onPageChangeListener);
+        }
+    }
+
+    public void removeOnPageChangeListener(ViewPagerEx.OnPageChangeListener onPageChangeListener) {
+        mViewPager.removeOnPageChangeListener(onPageChangeListener);
+    }
+
+    public void setCustomIndicator(PagerIndicator indicator){
+        if(mIndicator != null){
+            mIndicator.destroySelf();
+        }
+        mIndicator = indicator;
+        mIndicator.setIndicatorVisibility(mIndicatorVisibility);
+        mIndicator.setViewPager(mViewPager);
+        mIndicator.redraw();
+    }
+
+    public <T extends BaseSliderView> void addSlider(T imageContent){
+        mSliderAdapter.addSlider(imageContent);
+    }
+
+    private android.os.Handler mh = new android.os.Handler(){
+        @Override
+        public void handleMessage(Message msg) {
+            super.handleMessage(msg);
+            moveNextPosition(true);
+        }
+    };
+
+    public void startAutoCycle(){
+        startAutoCycle(mSliderDuration, mSliderDuration, mAutoRecover);
+    }
+
+    /**
+     * start auto cycle.
+     * @param delay delay time
+     * @param duration animation duration time.
+     * @param autoRecover if recover after user touches the slider.
+     */
+    public void startAutoCycle(long delay,long duration,boolean autoRecover){
+        if(mCycleTimer != null) mCycleTimer.cancel();
+        if(mCycleTask != null) mCycleTask.cancel();
+        if(mResumingTask != null) mResumingTask.cancel();
+        if(mResumingTimer != null) mResumingTimer.cancel();
+        mSliderDuration = duration;
+        mCycleTimer = new Timer();
+        mAutoRecover = autoRecover;
+        mCycleTask = new TimerTask() {
+            @Override
+            public void run() {
+                mh.sendEmptyMessage(0);
+            }
+        };
+        mCycleTimer.schedule(mCycleTask,delay,mSliderDuration);
+        mCycling = true;
+        mAutoCycle = true;
+    }
+
+    /**
+     * pause auto cycle.
+     */
+    private void pauseAutoCycle(){
+        if(mCycling){
+            mCycleTimer.cancel();
+            mCycleTask.cancel();
+            mCycling = false;
+        }else{
+            if(mResumingTimer != null && mResumingTask != null){
+                recoverCycle();
+            }
+        }
+    }
+
+    /**
+     * set the duration between two slider changes. the duration value must >= 500
+     * @param duration
+     */
+    public void setDuration(long duration){
+        if(duration >= 500){
+            mSliderDuration = duration;
+            if(mAutoCycle && mCycling){
+                startAutoCycle();
+            }
+        }
+    }
+
+    /**
+     * stop the auto circle
+     */
+    public void stopAutoCycle(){
+        if(mCycleTask!=null){
+            mCycleTask.cancel();
+        }
+        if(mCycleTimer!= null){
+            mCycleTimer.cancel();
+        }
+        if(mResumingTimer!= null){
+            mResumingTimer.cancel();
+        }
+        if(mResumingTask!=null){
+            mResumingTask.cancel();
+        }
+        mAutoCycle = false;
+        mCycling = false;
+    }
+
+    /**
+     * when paused cycle, this method can weak it up.
+     */
+    private void recoverCycle(){
+        if(!mAutoRecover || !mAutoCycle){
+            return;
+        }
+
+        if(!mCycling){
+            if(mResumingTask != null && mResumingTimer!= null){
+                mResumingTimer.cancel();
+                mResumingTask.cancel();
+            }
+            mResumingTimer = new Timer();
+            mResumingTask = new TimerTask() {
+                @Override
+                public void run() {
+                    startAutoCycle();
+                }
+            };
+            mResumingTimer.schedule(mResumingTask, 6000);
+        }
+    }
+
+
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent ev) {
+        int action = ev.getAction();
+        switch (action) {
+            case MotionEvent.ACTION_DOWN:
+                pauseAutoCycle();
+                break;
+        }
+        return false;
+    }
+
+    /**
+     * set ViewPager transformer.
+     * @param reverseDrawingOrder
+     * @param transformer
+     */
+    public void setPagerTransformer(boolean reverseDrawingOrder,BaseTransformer transformer){
+        mViewPagerTransformer = transformer;
+        mViewPagerTransformer.setCustomAnimationInterface(mCustomAnimation);
+        mViewPager.setPageTransformer(reverseDrawingOrder,mViewPagerTransformer);
+    }
+
+
+
+    /**
+     * set the duration between two slider changes.
+     * @param period
+     * @param interpolator
+     */
+    public void setSliderTransformDuration(int period,Interpolator interpolator){
+        try{
+            Field mScroller = ViewPagerEx.class.getDeclaredField("mScroller");
+            mScroller.setAccessible(true);
+            FixedSpeedScroller scroller = new FixedSpeedScroller(mViewPager.getContext(),interpolator, period);
+            mScroller.set(mViewPager,scroller);
+        }catch (Exception e){
+
+        }
+    }
+
+    /**
+     * preset transformers and their names
+     */
+    public enum Transformer{
+        Default("Default"),
+        Accordion("Accordion"),
+        Background2Foreground("Background2Foreground"),
+        CubeIn("CubeIn"),
+        DepthPage("DepthPage"),
+        Fade("Fade"),
+        FlipHorizontal("FlipHorizontal"),
+        FlipPage("FlipPage"),
+        Foreground2Background("Foreground2Background"),
+        RotateDown("RotateDown"),
+        RotateUp("RotateUp"),
+        Stack("Stack"),
+        Tablet("Tablet"),
+        ZoomIn("ZoomIn"),
+        ZoomOutSlide("ZoomOutSlide"),
+        ZoomOut("ZoomOut");
+
+        private final String name;
+
+        private Transformer(String s){
+            name = s;
+        }
+        public String toString(){
+            return name;
+        }
+
+        public boolean equals(String other){
+            return (other == null)? false:name.equals(other);
+        }
+    };
+
+    /**
+     * set a preset viewpager transformer by id.
+     * @param transformerId
+     */
+    public void setPresetTransformer(int transformerId){
+        for(Transformer t : Transformer.values()){
+            if(t.ordinal() == transformerId){
+                setPresetTransformer(t);
+                break;
+            }
+        }
+    }
+
+    /**
+     * set preset PagerTransformer via the name of transforemer.
+     * @param transformerName
+     */
+    public void setPresetTransformer(String transformerName){
+        for(Transformer t : Transformer.values()){
+            if(t.equals(transformerName)){
+                setPresetTransformer(t);
+                return;
+            }
+        }
+    }
+
+    /**
+     * Inject your custom animation into PageTransformer, you can know more details in
+     * {@link com.daimajia.slider.library.Animations.BaseAnimationInterface},
+     * and you can see a example in {@link com.daimajia.slider.library.Animations.DescriptionAnimation}
+     * @param animation
+     */
+    public void setCustomAnimation(BaseAnimationInterface animation){
+        mCustomAnimation = animation;
+        if(mViewPagerTransformer != null){
+            mViewPagerTransformer.setCustomAnimationInterface(mCustomAnimation);
+        }
+    }
+
+    /**
+     * pretty much right? enjoy it. :-D
+     *
+     * @param ts
+     */
+    public void setPresetTransformer(Transformer ts){
+        //
+        // special thanks to https://github.com/ToxicBakery/ViewPagerTransforms
+        //
+        BaseTransformer t = null;
+        switch (ts){
+            case Default:
+                t = new DefaultTransformer();
+                break;
+            case Accordion:
+                t = new AccordionTransformer();
+                break;
+            case Background2Foreground:
+                t = new BackgroundToForegroundTransformer();
+                break;
+            case CubeIn:
+                t = new CubeInTransformer();
+                break;
+            case DepthPage:
+                t = new DepthPageTransformer();
+                break;
+            case Fade:
+                t = new FadeTransformer();
+                break;
+            case FlipHorizontal:
+                t = new FlipHorizontalTransformer();
+                break;
+            case FlipPage:
+                t = new FlipPageViewTransformer();
+                break;
+            case Foreground2Background:
+                t = new ForegroundToBackgroundTransformer();
+                break;
+            case RotateDown:
+                t = new RotateDownTransformer();
+                break;
+            case RotateUp:
+                t = new RotateUpTransformer();
+                break;
+            case Stack:
+                t = new StackTransformer();
+                break;
+            case Tablet:
+                t = new TabletTransformer();
+                break;
+            case ZoomIn:
+                t = new ZoomInTransformer();
+                break;
+            case ZoomOutSlide:
+                t = new ZoomOutSlideTransformer();
+                break;
+            case ZoomOut:
+                t = new ZoomOutTransformer();
+                break;
+        }
+        setPagerTransformer(true,t);
+    }
+
+
+
+    /**
+     * Set the visibility of the indicators.
+     * @param visibility
+     */
+    public void setIndicatorVisibility(PagerIndicator.IndicatorVisibility visibility){
+        if(mIndicator == null){
+            return;
+        }
+
+        mIndicator.setIndicatorVisibility(visibility);
+    }
+
+    public PagerIndicator.IndicatorVisibility getIndicatorVisibility(){
+        if(mIndicator == null){
+            return mIndicator.getIndicatorVisibility();
+        }
+        return PagerIndicator.IndicatorVisibility.Invisible;
+
+    }
+
+    /**
+     * get the {@link com.daimajia.slider.library.Indicators.PagerIndicator} instance.
+     * You can manipulate the properties of the indicator.
+     * @return
+     */
+    public PagerIndicator getPagerIndicator(){
+        return mIndicator;
+    }
+
+    public enum PresetIndicators{
+        Center_Bottom("Center_Bottom",R.id.default_center_bottom_indicator),
+        Right_Bottom("Right_Bottom",R.id.default_bottom_right_indicator),
+        Left_Bottom("Left_Bottom",R.id.default_bottom_left_indicator),
+        Center_Top("Center_Top",R.id.default_center_top_indicator),
+        Right_Top("Right_Top",R.id.default_center_top_right_indicator),
+        Left_Top("Left_Top",R.id.default_center_top_left_indicator);
+
+        private final String name;
+        private final int id;
+        private PresetIndicators(String name,int id){
+            this.name = name;
+            this.id = id;
+        }
+
+        public String toString(){
+            return name;
+        }
+
+        public int getResourceId(){
+            return id;
+        }
+    }
+    public void setPresetIndicator(PresetIndicators presetIndicator){
+        PagerIndicator pagerIndicator = (PagerIndicator)findViewById(presetIndicator.getResourceId());
+        setCustomIndicator(pagerIndicator);
+    }
+
+    private InfinitePagerAdapter getWrapperAdapter(){
+        PagerAdapter adapter = mViewPager.getAdapter();
+        if(adapter!=null){
+            return (InfinitePagerAdapter)adapter;
+        }else{
+            return null;
+        }
+    }
+
+    private SliderAdapter getRealAdapter(){
+        PagerAdapter adapter = mViewPager.getAdapter();
+        if(adapter!=null){
+            return ((InfinitePagerAdapter)adapter).getRealAdapter();
+        }
+        return null;
+    }
+
+    /**
+     * get the current item position
+     * @return
+     */
+    public int getCurrentPosition(){
+
+        if(getRealAdapter() == null)
+            throw new IllegalStateException("You did not set a slider adapter");
+
+        return mViewPager.getCurrentItem() % getRealAdapter().getCount();
+
+    }
+
+    /**
+     * get current slider.
+     * @return
+     */
+    public BaseSliderView getCurrentSlider(){
+
+        if(getRealAdapter() == null)
+            throw new IllegalStateException("You did not set a slider adapter");
+
+        int count = getRealAdapter().getCount();
+        int realCount = mViewPager.getCurrentItem() % count;
+        return  getRealAdapter().getSliderView(realCount);
+    }
+
+    /**
+     * remove  the slider at the position. Notice: It's a not perfect method, a very small bug still exists.
+     */
+    public void removeSliderAt(int position){
+        if(getRealAdapter()!=null){
+            getRealAdapter().removeSliderAt(position);
+            mViewPager.setCurrentItem(mViewPager.getCurrentItem(),false);
+        }
+    }
+
+    /**
+     * remove all the sliders. Notice: It's a not perfect method, a very small bug still exists.
+     */
+    public void removeAllSliders(){
+        if(getRealAdapter()!=null){
+            int count = getRealAdapter().getCount();
+            getRealAdapter().removeAllSliders();
+            //a small bug, but fixed by this trick.
+            //bug: when remove adapter's all the sliders.some caching slider still alive.
+            mViewPager.setCurrentItem(mViewPager.getCurrentItem() +  count,false);
+        }
+    }
+
+    /**
+     *set current slider
+     * @param position
+     */
+    public void setCurrentPosition(int position, boolean smooth) {
+        if (getRealAdapter() == null)
+            throw new IllegalStateException("You did not set a slider adapter");
+        if(position >= getRealAdapter().getCount()){
+            throw new IllegalStateException("Item position is not exist");
+        }
+        int p = mViewPager.getCurrentItem() % getRealAdapter().getCount();
+        int n = (position - p) + mViewPager.getCurrentItem();
+        mViewPager.setCurrentItem(n, smooth);
+    }
+
+    public void setCurrentPosition(int position) {
+        setCurrentPosition(position, true);
+    }
+
+    /**
+     * move to prev slide.
+     */
+    public void movePrevPosition(boolean smooth) {
+
+        if (getRealAdapter() == null)
+            throw new IllegalStateException("You did not set a slider adapter");
+
+        mViewPager.setCurrentItem(mViewPager.getCurrentItem() - 1, smooth);
+    }
+
+    public void movePrevPosition(){
+        movePrevPosition(true);
+    }
+
+    /**
+     * move to next slide.
+     */
+    public void moveNextPosition(boolean smooth) {
+
+        if (getRealAdapter() == null)
+            throw new IllegalStateException("You did not set a slider adapter");
+
+        mViewPager.setCurrentItem(mViewPager.getCurrentItem() + 1, smooth);
+    }
+
+    public void moveNextPosition() {
+        moveNextPosition(true);
+    }
+}
Index: library/src/main/java/com/daimajia/slider/library/Transformers/ZoomOutTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/ZoomOutTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/ZoomOutTransformer.java	(revision )
@@ -0,0 +1,23 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class ZoomOutTransformer extends BaseTransformer {
+
+    @Override
+    protected void onTransform(View view, float position) {
+        final float scale = 1f + Math.abs(position);
+        ViewHelper.setScaleX(view,scale);
+        ViewHelper.setScaleY(view,scale);
+        ViewHelper.setPivotX(view,view.getWidth() * 0.5f);
+        ViewHelper.setPivotY(view,view.getWidth() * 0.5f);
+        ViewHelper.setAlpha(view,position < -1f || position > 1f ? 0f : 1f - (scale - 1f));
+        if(position < -0.9){
+            //-0.9 to prevent a small bug
+            ViewHelper.setTranslationX(view,view.getWidth() * position);
+        }
+    }
+
+}
\ No newline at end of file
Index: library/src/main/res/drawable/indicator_corner_bg.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/res/drawable/indicator_corner_bg.xml	(revision )
+++ library/src/main/res/drawable/indicator_corner_bg.xml	(revision )
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<layer-list  xmlns:android="http://schemas.android.com/apk/res/android">
+    <item>
+        <shape android:shape="rectangle">
+            <corners android:radius="12dp"/>
+            <solid android:color="#33000000"/>
+        </shape>
+    </item>
+</layer-list>
\ No newline at end of file
Index: gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- gradle.properties	(revision )
+++ gradle.properties	(revision )
@@ -0,0 +1,34 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Settings specified in this file will override any Gradle settings
+# configured through the IDE.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
+
+
+VERSION_NAME=1.1.2
+VERSION_CODE=13
+GROUP=com.daimajia.slider
+
+POM_DESCRIPTION=An amazing and convenient Android image slider.
+POM_URL=https://github.com/daimajia/AndroidImageSlider
+POM_SCM_URL=https://github.com/daimajia/AndroidImageSlider
+POM_SCM_CONNECTION=scm:https://github.com/daimajia/AndroidImageSlider.git
+POM_SCM_DEV_CONNECTION=scm:https://github.com/daimajia/AndroidImageSlider.git
+POM_LICENCE_NAME=MIT
+POM_LICENCE_URL=http://opensource.org/licenses/MIT
+POM_LICENCE_DIST=repo
+POM_DEVELOPER_ID=daimajia
+POM_DEVELOPER_NAME=daimajia
\ No newline at end of file
Index: library/src/main/java/com/daimajia/slider/library/SliderAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/SliderAdapter.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/SliderAdapter.java	(revision )
@@ -0,0 +1,109 @@
+package com.daimajia.slider.library;
+
+import android.content.Context;
+import android.support.v4.view.PagerAdapter;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.daimajia.slider.library.SliderTypes.BaseSliderView;
+
+import java.util.ArrayList;
+
+/**
+ * A slider adapter
+ */
+public class SliderAdapter extends PagerAdapter implements BaseSliderView.ImageLoadListener{
+
+    private Context mContext;
+    private ArrayList<BaseSliderView> mImageContents;
+
+    public SliderAdapter(Context context){
+        mContext = context;
+        mImageContents = new ArrayList<BaseSliderView>();
+    }
+
+    public <T extends BaseSliderView> void addSlider(T slider){
+        slider.setOnImageLoadListener(this);
+        mImageContents.add(slider);
+        notifyDataSetChanged();
+    }
+
+    public BaseSliderView getSliderView(int position){
+        if(position < 0 || position >= mImageContents.size()){
+            return null;
+        }else{
+            return mImageContents.get(position);
+        }
+    }
+
+    @Override
+    public int getItemPosition(Object object) {
+        return POSITION_NONE;
+    }
+
+    public <T extends BaseSliderView> void removeSlider(T slider){
+        if(mImageContents.contains(slider)){
+            mImageContents.remove(slider);
+            notifyDataSetChanged();
+        }
+    }
+
+    public void removeSliderAt(int position){
+        if(mImageContents.size() > position){
+            mImageContents.remove(position);
+            notifyDataSetChanged();
+        }
+    }
+
+    public void removeAllSliders(){
+        mImageContents.clear();
+        notifyDataSetChanged();
+    }
+
+    @Override
+    public int getCount() {
+        return mImageContents.size();
+    }
+
+    @Override
+    public boolean isViewFromObject(View view, Object object) {
+        return view==object;
+    }
+
+    @Override
+    public void destroyItem(ViewGroup container, int position, Object object) {
+        container.removeView((View) object);
+    }
+
+    @Override
+    public Object instantiateItem(ViewGroup container, int position) {
+        BaseSliderView b = mImageContents.get(position);
+        View v = b.getView();
+        container.addView(v);
+        return v;
+    }
+
+    @Override
+    public void onStart(BaseSliderView target) {
+
+    }
+
+    /**
+     * When image download error, then remove.
+     * @param result
+     * @param target
+     */
+    @Override
+    public void onEnd(boolean result, BaseSliderView target) {
+        if(target.isErrorDisappear() == false || result == true){
+            return;
+        }
+        for (BaseSliderView slider: mImageContents){
+            if(slider.equals(target)){
+                removeSlider(target);
+                break;
+            }
+        }
+    }
+
+}
Index: library/src/main/java/com/daimajia/slider/library/SliderTypes/TextSliderView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/SliderTypes/TextSliderView.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/SliderTypes/TextSliderView.java	(revision )
@@ -0,0 +1,28 @@
+package com.daimajia.slider.library.SliderTypes;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.daimajia.slider.library.R;
+
+/**
+ * This is a slider with a description TextView.
+ */
+public class TextSliderView extends BaseSliderView{
+    public TextSliderView(Context context) {
+        super(context);
+    }
+
+    @Override
+    public View getView() {
+        View v = LayoutInflater.from(getContext()).inflate(R.layout.render_type_text,null);
+        ImageView target = (ImageView)v.findViewById(R.id.daimajia_slider_image);
+        TextView description = (TextView)v.findViewById(R.id.description);
+        description.setText(getDescription());
+        bindEventAndShow(v, target);
+        return v;
+    }
+}
Index: library/src/main/res/values/attrs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/res/values/attrs.xml	(revision )
+++ library/src/main/res/values/attrs.xml	(revision )
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <declare-styleable name="SliderLayout">
+
+        <!-- indicator visibility -->
+        <attr name="indicator_visibility" format="enum">
+            <enum name="visible" value="0"/>
+            <enum name="invisible" value="1"/>
+        </attr>
+
+        <attr name="auto_cycle" format="boolean"/>
+
+        <!-- page animation -->
+        <attr name="pager_animation" format="enum">
+            <enum name="Default" value="0">Default</enum>
+            <enum name="Accordion" value="1">Accordion</enum>
+            <enum name="Background2Foreground" value="2">Background2Foreground</enum>
+            <enum name="CubeIn" value="3">CubeIn</enum>
+            <enum name="DepthPage" value="4">DepthPage</enum>
+            <enum name="Fade" value="5">Fade</enum>
+            <enum name="FlipHorizontal" value="6">FlipHorizontal</enum>
+            <enum name="FlipPage" value="7">FlipPage</enum>
+            <enum name="Foreground2Background" value="8">Foreground2Background</enum>
+            <enum name="RotateDown" value="9">RotateDown</enum>
+            <enum name="RotateUp" value="10">RotateUp</enum>
+            <enum name="Stack" value="11">Stack</enum>
+            <enum name="Tablet" value="12">Tablet</enum>
+            <enum name="ZoomIn" value="13">ZoomIn</enum>
+            <enum name="ZoomOutSlide" value="14">ZoomOutSlide</enum>
+            <enum name="ZoomOut" value="15">ZoomOut</enum>
+        </attr>
+
+        <!-- page animation time span -->
+        <attr name="pager_animation_span" format="integer"/>
+
+    </declare-styleable>
+
+    <declare-styleable name="PagerIndicator">
+        <!-- indicator visibility -->
+        <attr name="visibility" format="enum">
+            <enum name="visible" value="0"/>
+            <enum name="invisible" value="1"/>
+        </attr>
+
+        <attr name="shape" format="enum">
+            <enum value="0" name="oval"/>
+            <enum value="1" name="rect"/>
+        </attr>
+
+        <attr name="selected_color" format="color"/>
+        <attr name="unselected_color" format="color"/>
+
+        <!-- indicator style -->
+        <attr name="selected_drawable" format="reference"/>
+        <attr name="unselected_drawable" format="reference"/>
+
+        <attr name="selected_width" format="dimension"/>
+        <attr name="selected_height" format="dimension"/>
+
+        <attr name="unselected_width" format="dimension"/>
+        <attr name="unselected_height" format="dimension"/>
+
+        <attr name="padding_left" format="dimension"/>
+        <attr name="padding_right" format="dimension"/>
+        <attr name="padding_top" format="dimension"/>
+        <attr name="padding_bottom" format="dimension"/>
+
+        <attr name="selected_padding_left" format="dimension"/>
+        <attr name="selected_padding_right" format="dimension"/>
+        <attr name="selected_padding_top" format="dimension"/>
+        <attr name="selected_padding_bottom" format="dimension"/>
+
+        <attr name="unselected_padding_left" format="dimension"/>
+        <attr name="unselected_padding_right" format="dimension"/>
+        <attr name="unselected_padding_top" format="dimension"/>
+        <attr name="unselected_padding_bottom" format="dimension"/>
+
+
+    </declare-styleable>
+
+    <declare-styleable name="Themes">
+        <attr name="SliderStyle" format="reference"/>
+        <attr name="PagerIndicatorStyle" format="reference"/>
+    </declare-styleable>
+</resources>
\ No newline at end of file
Index: gradlew.bat
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- gradlew.bat	(revision )
+++ gradlew.bat	(revision )
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
Index: library/src/main/java/com/daimajia/slider/library/Transformers/DefaultTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/DefaultTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/DefaultTransformer.java	(revision )
@@ -0,0 +1,16 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+public class DefaultTransformer extends BaseTransformer {
+
+	@Override
+	protected void onTransform(View view, float position) {
+	}
+
+	@Override
+	public boolean isPagingEnabled() {
+		return true;
+	}
+
+}
Index: library/src/main/res/layout/render_type_default.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/res/layout/render_type_default.xml	(revision )
+++ library/src/main/res/layout/render_type_default.xml	(revision )
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent" android:layout_height="match_parent">
+    <ImageView
+        android:id="@+id/daimajia_slider_image"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
+    <ProgressBar
+        android:id="@+id/loading_bar"
+        android:layout_centerInParent="true"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content" />
+</RelativeLayout>
\ No newline at end of file
Index: demo/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/AndroidManifest.xml	(revision )
+++ demo/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.daimajia.slider.demo" >
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name="com.daimajia.slider.demo.MainActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
Index: LICENSE
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- LICENSE	(revision )
+++ LICENSE	(revision )
@@ -0,0 +1,19 @@
+The MIT License
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
Index: library/src/main/java/com/daimajia/slider/library/Transformers/ZoomOutSlideTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/ZoomOutSlideTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/ZoomOutSlideTransformer.java	(revision )
@@ -0,0 +1,40 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class ZoomOutSlideTransformer extends BaseTransformer {
+
+	private static final float MIN_SCALE = 0.85f;
+	private static final float MIN_ALPHA = 0.5f;
+
+	@Override
+	protected void onTransform(View view, float position) {
+		if (position >= -1 || position <= 1) {
+			// Modify the default slide transition to shrink the page as well
+			final float height = view.getHeight();
+			final float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));
+			final float vertMargin = height * (1 - scaleFactor) / 2;
+			final float horzMargin = view.getWidth() * (1 - scaleFactor) / 2;
+
+            // Center vertically
+            ViewHelper.setPivotY(view,0.5f * height);
+
+
+			if (position < 0) {
+                ViewHelper.setTranslationX(view,horzMargin - vertMargin / 2);
+			} else {
+                ViewHelper.setTranslationX(view,-horzMargin + vertMargin / 2);
+			}
+
+			// Scale the page down (between MIN_SCALE and 1)
+			ViewHelper.setScaleX(view,scaleFactor);
+            ViewHelper.setScaleY(view,scaleFactor);
+
+			// Fade the page relative to its size.
+            ViewHelper.setAlpha(view,MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA));
+		}
+	}
+
+}
Index: demo/src/main/res/values-w820dp/dimens.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- demo/src/main/res/values-w820dp/dimens.xml	(revision )
+++ demo/src/main/res/values-w820dp/dimens.xml	(revision )
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
Index: library/src/main/java/com/daimajia/slider/library/Tricks/ViewPagerEx.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Tricks/ViewPagerEx.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Tricks/ViewPagerEx.java	(revision )
@@ -0,0 +1,2908 @@
+package com.daimajia.slider.library.Tricks;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.database.DataSetObserver;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.SystemClock;
+import android.support.v4.os.ParcelableCompat;
+import android.support.v4.os.ParcelableCompatCreatorCallbacks;
+import android.support.v4.view.AccessibilityDelegateCompat;
+import android.support.v4.view.KeyEventCompat;
+import android.support.v4.view.MotionEventCompat;
+import android.support.v4.view.PagerAdapter;
+import android.support.v4.view.VelocityTrackerCompat;
+import android.support.v4.view.ViewCompat;
+import android.support.v4.view.ViewConfigurationCompat;
+import android.support.v4.view.accessibility.AccessibilityEventCompat;
+import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
+import android.support.v4.view.accessibility.AccessibilityRecordCompat;
+import android.support.v4.widget.EdgeEffectCompat;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.FocusFinder;
+import android.view.Gravity;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.SoundEffectConstants;
+import android.view.VelocityTracker;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.ViewParent;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.animation.Interpolator;
+import android.widget.Scroller;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+
+/**
+ * Layout manager that allows the user to flip left and right
+ * through pages of data.  You supply an implementation of a
+ * {@link PagerAdapter} to generate the pages that the view shows.
+ *
+ * <p>Note this class is currently under early design and
+ * development.  The API will likely change in later updates of
+ * the compatibility library, requiring changes to the source code
+ * of apps when they are compiled against the newer version.</p>
+ *
+ * <p>ViewPager is most often used in conjunction with {@link android.app.Fragment},
+ * which is a convenient way to supply and manage the lifecycle of each page.
+ * There are standard adapters implemented for using fragments with the ViewPager,
+ * which cover the most common use cases.  These are
+ * {@link android.support.v4.app.FragmentPagerAdapter} and
+ * {@link android.support.v4.app.FragmentStatePagerAdapter}; each of these
+ * classes have simple code showing how to build a full user interface
+ * with them.
+ *
+ * <p>Here is a more complicated example of ViewPager, using it in conjuction
+ * with {@link android.app.ActionBar} tabs.  You can find other examples of using
+ * ViewPager in the API 4+ Support Demos and API 13+ Support Demos sample code.
+ *
+ * {@sample development/samples/Support13Demos/src/com/example/android/supportv13/app/ActionBarTabsPager.java
+ *      complete}
+ */
+
+
+/**
+ * @author daimajia : I just remove the if condition in setPageTransformer() to make it compatiable with Android 2.0+
+ * of course, with the help of the NineOldDroid.
+ * Thanks to JakeWharton.
+ * http://github.com/JakeWharton/NineOldAndroids
+ */
+public class ViewPagerEx extends ViewGroup{
+    private static final String TAG = "ViewPagerEx";
+    private static final boolean DEBUG = false;
+
+    private static final boolean USE_CACHE = false;
+
+    private static final int DEFAULT_OFFSCREEN_PAGES = 1;
+    private static final int MAX_SETTLE_DURATION = 600; // ms
+    private static final int MIN_DISTANCE_FOR_FLING = 25; // dips
+
+    private static final int DEFAULT_GUTTER_SIZE = 16; // dips
+
+    private static final int MIN_FLING_VELOCITY = 400; // dips
+
+    private static final int[] LAYOUT_ATTRS = new int[] {
+            android.R.attr.layout_gravity
+    };
+
+    /**
+     * Used to track what the expected number of items in the adapter should be.
+     * If the app changes this when we don't expect it, we'll throw a big obnoxious exception.
+     */
+    private int mExpectedAdapterCount;
+
+    static class ItemInfo {
+        Object object;
+        int position;
+        boolean scrolling;
+        float widthFactor;
+        float offset;
+    }
+
+    private static final Comparator<ItemInfo> COMPARATOR = new Comparator<ItemInfo>(){
+        @Override
+        public int compare(ItemInfo lhs, ItemInfo rhs) {
+            return lhs.position - rhs.position;
+        }
+    };
+
+    private static final Interpolator sInterpolator = new Interpolator() {
+        public float getInterpolation(float t) {
+            t -= 1.0f;
+            return t * t * t * t * t + 1.0f;
+        }
+    };
+
+    private final ArrayList<ItemInfo> mItems = new ArrayList<ItemInfo>();
+    private final ItemInfo mTempItem = new ItemInfo();
+
+    private final Rect mTempRect = new Rect();
+
+    private PagerAdapter mAdapter;
+    private int mCurItem;   // Index of currently displayed page.
+    private int mRestoredCurItem = -1;
+    private Parcelable mRestoredAdapterState = null;
+    private ClassLoader mRestoredClassLoader = null;
+    private Scroller mScroller;
+    private PagerObserver mObserver;
+
+    private int mPageMargin;
+    private Drawable mMarginDrawable;
+    private int mTopPageBounds;
+    private int mBottomPageBounds;
+
+    // Offsets of the first and last items, if known.
+    // Set during population, used to determine if we are at the beginning
+    // or end of the pager data set during touch scrolling.
+    private float mFirstOffset = -Float.MAX_VALUE;
+    private float mLastOffset = Float.MAX_VALUE;
+
+    private int mChildWidthMeasureSpec;
+    private int mChildHeightMeasureSpec;
+    private boolean mInLayout;
+
+    private boolean mScrollingCacheEnabled;
+
+    private boolean mPopulatePending;
+    private int mOffscreenPageLimit = DEFAULT_OFFSCREEN_PAGES;
+
+    private boolean mIsBeingDragged;
+    private boolean mIsUnableToDrag;
+    private boolean mIgnoreGutter;
+    private int mDefaultGutterSize;
+    private int mGutterSize;
+    private int mTouchSlop;
+    /**
+     * Position of the last motion event.
+     */
+    private float mLastMotionX;
+    private float mLastMotionY;
+    private float mInitialMotionX;
+    private float mInitialMotionY;
+    /**
+     * ID of the active pointer. This is used to retain consistency during
+     * drags/flings if multiple pointers are used.
+     */
+    private int mActivePointerId = INVALID_POINTER;
+    /**
+     * Sentinel value for no current active pointer.
+     * Used by {@link #mActivePointerId}.
+     */
+    private static final int INVALID_POINTER = -1;
+
+    /**
+     * Determines speed during touch scrolling
+     */
+    private VelocityTracker mVelocityTracker;
+    private int mMinimumVelocity;
+    private int mMaximumVelocity;
+    private int mFlingDistance;
+    private int mCloseEnough;
+
+    // If the pager is at least this close to its final position, complete the scroll
+    // on touch down and let the user interact with the content inside instead of
+    // "catching" the flinging pager.
+    private static final int CLOSE_ENOUGH = 2; // dp
+
+    private boolean mFakeDragging;
+    private long mFakeDragBeginTime;
+
+    private EdgeEffectCompat mLeftEdge;
+    private EdgeEffectCompat mRightEdge;
+
+    private boolean mFirstLayout = true;
+    private boolean mNeedCalculatePageOffsets = false;
+    private boolean mCalledSuper;
+    private int mDecorChildCount;
+
+    private ArrayList<OnPageChangeListener> mOnPageChangeListeners = new ArrayList<>();
+    private OnPageChangeListener mInternalPageChangeListener;
+    private OnAdapterChangeListener mAdapterChangeListener;
+    private PageTransformer mPageTransformer;
+    private Method mSetChildrenDrawingOrderEnabled;
+
+    private static final int DRAW_ORDER_DEFAULT = 0;
+    private static final int DRAW_ORDER_FORWARD = 1;
+    private static final int DRAW_ORDER_REVERSE = 2;
+    private int mDrawingOrder;
+    private ArrayList<View> mDrawingOrderedChildren;
+    private static final ViewPositionComparator sPositionComparator = new ViewPositionComparator();
+
+    /**
+     * Indicates that the pager is in an idle, settled state. The current page
+     * is fully in view and no animation is in progress.
+     */
+    public static final int SCROLL_STATE_IDLE = 0;
+
+    /**
+     * Indicates that the pager is currently being dragged by the user.
+     */
+    public static final int SCROLL_STATE_DRAGGING = 1;
+
+    /**
+     * Indicates that the pager is in the process of settling to a final position.
+     */
+    public static final int SCROLL_STATE_SETTLING = 2;
+
+    private final Runnable mEndScrollRunnable = new Runnable() {
+        public void run() {
+            setScrollState(SCROLL_STATE_IDLE);
+            populate();
+        }
+    };
+
+    private int mScrollState = SCROLL_STATE_IDLE;
+
+    /**
+     * Callback interface for responding to changing state of the selected page.
+     */
+    public interface OnPageChangeListener {
+
+        /**
+         * This method will be invoked when the current page is scrolled, either as part
+         * of a programmatically initiated smooth scroll or a user initiated touch scroll.
+         *
+         * @param position Position index of the first page currently being displayed.
+         *                 Page position+1 will be visible if positionOffset is nonzero.
+         * @param positionOffset Value from [0, 1) indicating the offset from the page at position.
+         * @param positionOffsetPixels Value in pixels indicating the offset from position.
+         */
+        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels);
+
+        /**
+         * This method will be invoked when a new page becomes selected. Animation is not
+         * necessarily complete.
+         *
+         * @param position Position index of the new selected page.
+         */
+        public void onPageSelected(int position);
+
+        /**
+         * Called when the scroll state changes. Useful for discovering when the user
+         * begins dragging, when the pager is automatically settling to the current page,
+         * or when it is fully stopped/idle.
+         *
+         * @param state The new scroll state.
+         * @see ViewPagerEx#SCROLL_STATE_IDLE
+         * @see ViewPagerEx#SCROLL_STATE_DRAGGING
+         * @see ViewPagerEx#SCROLL_STATE_SETTLING
+         */
+        public void onPageScrollStateChanged(int state);
+    }
+
+    /**
+     * Simple implementation of the {@link OnPageChangeListener} interface with stub
+     * implementations of each method. Extend this if you do not intend to override
+     * every method of {@link OnPageChangeListener}.
+     */
+    public static class SimpleOnPageChangeListener implements OnPageChangeListener {
+        @Override
+        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+            // This space for rent
+        }
+
+        @Override
+        public void onPageSelected(int position) {
+            // This space for rent
+        }
+
+        @Override
+        public void onPageScrollStateChanged(int state) {
+            // This space for rent
+        }
+    }
+
+    private void triggerOnPageChangeEvent(int position) {
+        for (OnPageChangeListener eachListener : mOnPageChangeListeners) {
+            if (eachListener != null) {
+                InfinitePagerAdapter infiniteAdapter = (InfinitePagerAdapter)mAdapter;
+                if (infiniteAdapter.getRealCount() == 0) {
+                    return;
+                }
+                int n = position % infiniteAdapter.getRealCount();
+                eachListener.onPageSelected(n);
+            }
+        }
+        if (mInternalPageChangeListener != null) {
+            mInternalPageChangeListener.onPageSelected(position);
+        }
+    }
+    /**
+     * A PageTransformer is invoked whenever a visible/attached page is scrolled.
+     * This offers an opportunity for the application to apply a custom transformation
+     * to the page views using animation properties.
+     *
+     * <p>As property animation is only supported as of Android 3.0 and forward,
+     * setting a PageTransformer on a ViewPager on earlier platform versions will
+     * be ignored.</p>
+     */
+    public interface PageTransformer {
+        /**
+         * Apply a property transformation to the given page.
+         *
+         * @param page Apply the transformation to this page
+         * @param position Position of page relative to the current front-and-center
+         *                 position of the pager. 0 is front and center. 1 is one full
+         *                 page position to the right, and -1 is one page position to the left.
+         */
+        public void transformPage(View page, float position);
+
+    }
+
+    /**
+     * Used internally to monitor when adapters are switched.
+     */
+    interface OnAdapterChangeListener {
+        public void onAdapterChanged(PagerAdapter oldAdapter, PagerAdapter newAdapter);
+    }
+
+    /**
+     * Used internally to tag special types of child views that should be added as
+     * pager decorations by default.
+     */
+    interface Decor {}
+
+    public ViewPagerEx(Context context) {
+        super(context);
+        initViewPager();
+    }
+
+    public ViewPagerEx(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initViewPager();
+    }
+
+    void initViewPager() {
+        setWillNotDraw(false);
+        setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
+        setFocusable(true);
+        final Context context = getContext();
+        mScroller = new Scroller(context, sInterpolator);
+        final ViewConfiguration configuration = ViewConfiguration.get(context);
+        final float density = context.getResources().getDisplayMetrics().density;
+
+        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
+        mMinimumVelocity = (int) (MIN_FLING_VELOCITY * density);
+        mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
+        mLeftEdge = new EdgeEffectCompat(context);
+        mRightEdge = new EdgeEffectCompat(context);
+
+        mFlingDistance = (int) (MIN_DISTANCE_FOR_FLING * density);
+        mCloseEnough = (int) (CLOSE_ENOUGH * density);
+        mDefaultGutterSize = (int) (DEFAULT_GUTTER_SIZE * density);
+
+        ViewCompat.setAccessibilityDelegate(this, new MyAccessibilityDelegate());
+
+        if (ViewCompat.getImportantForAccessibility(this)
+                == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
+            ViewCompat.setImportantForAccessibility(this,
+                    ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
+        }
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        removeCallbacks(mEndScrollRunnable);
+        super.onDetachedFromWindow();
+    }
+
+    private void setScrollState(int newState) {
+        if (mScrollState == newState) {
+            return;
+        }
+
+        mScrollState = newState;
+        if (mPageTransformer != null) {
+            // PageTransformers can do complex things that benefit from hardware layers.
+            enableLayers(newState != SCROLL_STATE_IDLE);
+        }
+        for (OnPageChangeListener eachListener : mOnPageChangeListeners) {
+            if (eachListener != null) {
+                eachListener.onPageScrollStateChanged(newState);
+            }
+        }
+    }
+
+    /**
+     * Set a PagerAdapter that will supply views for this pager as needed.
+     *
+     * @param adapter Adapter to use
+     */
+    public void setAdapter(PagerAdapter adapter) {
+        if (mAdapter != null) {
+            mAdapter.unregisterDataSetObserver(mObserver);
+            mAdapter.startUpdate(this);
+            for (int i = 0; i < mItems.size(); i++) {
+                final ItemInfo ii = mItems.get(i);
+                mAdapter.destroyItem(this, ii.position, ii.object);
+            }
+            mAdapter.finishUpdate(this);
+            mItems.clear();
+            removeNonDecorViews();
+            mCurItem = 0;
+            scrollTo(0, 0);
+        }
+
+        final PagerAdapter oldAdapter = mAdapter;
+        mAdapter = adapter;
+        mExpectedAdapterCount = 0;
+
+        if (mAdapter != null) {
+            if (mObserver == null) {
+                mObserver = new PagerObserver();
+            }
+            mAdapter.registerDataSetObserver(mObserver);
+            mPopulatePending = false;
+            final boolean wasFirstLayout = mFirstLayout;
+            mFirstLayout = true;
+            mExpectedAdapterCount = mAdapter.getCount();
+            if (mRestoredCurItem >= 0) {
+                mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);
+                setCurrentItemInternal(mRestoredCurItem, false, true);
+                mRestoredCurItem = -1;
+                mRestoredAdapterState = null;
+                mRestoredClassLoader = null;
+            } else if (!wasFirstLayout) {
+                populate();
+            } else {
+                requestLayout();
+            }
+        }
+
+        if (mAdapterChangeListener != null && oldAdapter != adapter) {
+            mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);
+        }
+    }
+
+    private void removeNonDecorViews() {
+        for (int i = 0; i < getChildCount(); i++) {
+            final View child = getChildAt(i);
+            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+            if (!lp.isDecor) {
+                removeViewAt(i);
+                i--;
+            }
+        }
+    }
+
+    /**
+     * Retrieve the current adapter supplying pages.
+     *
+     * @return The currently registered PagerAdapter
+     */
+    public PagerAdapter getAdapter() {
+        return mAdapter;
+    }
+
+    void setOnAdapterChangeListener(OnAdapterChangeListener listener) {
+        mAdapterChangeListener = listener;
+    }
+
+    private int getClientWidth() {
+        return getMeasuredWidth() - getPaddingLeft() - getPaddingRight();
+    }
+
+    /**
+     * Set the currently selected page. If the ViewPager has already been through its first
+     * layout with its current adapter there will be a smooth animated transition between
+     * the current item and the specified item.
+     *
+     * @param item Item index to select
+     */
+    public void setCurrentItem(int item) {
+        mPopulatePending = false;
+        setCurrentItemInternal(item, !mFirstLayout, false);
+    }
+
+    /**
+     * Set the currently selected page.
+     *
+     * @param item Item index to select
+     * @param smoothScroll True to smoothly scroll to the new item, false to transition immediately
+     */
+    public void setCurrentItem(int item, boolean smoothScroll) {
+        mPopulatePending = false;
+        setCurrentItemInternal(item, smoothScroll, false);
+    }
+
+    public int getCurrentItem() {
+        return mCurItem;
+    }
+
+    void setCurrentItemInternal(int item, boolean smoothScroll, boolean always) {
+        setCurrentItemInternal(item, smoothScroll, always, 0);
+    }
+
+    void setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity) {
+        if (mAdapter == null || mAdapter.getCount() <= 0) {
+            setScrollingCacheEnabled(false);
+            return;
+        }
+        if (!always && mCurItem == item && mItems.size() != 0) {
+            setScrollingCacheEnabled(false);
+            return;
+        }
+
+        if (item < 0) {
+            item = 0;
+        } else if (item >= mAdapter.getCount()) {
+            item = mAdapter.getCount() - 1;
+        }
+        final int pageLimit = mOffscreenPageLimit;
+        if (item > (mCurItem + pageLimit) || item < (mCurItem - pageLimit)) {
+            // We are doing a jump by more than one page.  To avoid
+            // glitches, we want to keep all current pages in the view
+            // until the scroll ends.
+            for (int i=0; i<mItems.size(); i++) {
+                mItems.get(i).scrolling = true;
+            }
+        }
+        final boolean dispatchSelected = mCurItem != item;
+
+        if (mFirstLayout) {
+            // We don't have any idea how big we are yet and shouldn't have any pages either.
+            // Just set things up and let the pending layout handle things.
+            mCurItem = item;
+            triggerOnPageChangeEvent(item);
+            requestLayout();
+        } else {
+            populate(item);
+            scrollToItem(item, smoothScroll, velocity, dispatchSelected);
+        }
+    }
+
+    private void scrollToItem(int item, boolean smoothScroll, int velocity,
+                              boolean dispatchSelected) {
+        final ItemInfo curInfo = infoForPosition(item);
+        int destX = 0;
+        if (curInfo != null) {
+            final int width = getClientWidth();
+            destX = (int) (width * Math.max(mFirstOffset,
+                    Math.min(curInfo.offset, mLastOffset)));
+        }
+        if (smoothScroll) {
+            smoothScrollTo(destX, 0, velocity);
+            if (dispatchSelected) {
+                triggerOnPageChangeEvent(item);
+            }
+        } else {
+            if (dispatchSelected) {
+                triggerOnPageChangeEvent(item);
+            }
+            completeScroll(false);
+            scrollTo(destX, 0);
+            pageScrolled(destX);
+        }
+    }
+
+    /**
+     * Add a listener that will be invoked whenever the page changes or is incrementally
+     * scrolled. See {@link OnPageChangeListener}.
+     *
+     * @param listener Listener to add
+     */
+    public void addOnPageChangeListener(OnPageChangeListener listener) {
+        if (!mOnPageChangeListeners.contains(listener)) {
+            mOnPageChangeListeners.add(listener);
+        }
+    }
+
+    /**
+     * Remove a listener that was added with addOnPageChangeListener
+     * See {@link OnPageChangeListener}.
+     *
+     * @param listener Listener to remove
+     */
+    public void removeOnPageChangeListener(OnPageChangeListener listener) {
+        mOnPageChangeListeners.remove(listener);
+    }
+
+    /**
+     * Set a {@link PageTransformer} that will be called for each attached page whenever
+     * the scroll position is changed. This allows the application to apply custom property
+     * transformations to each page, overriding the default sliding look and feel.
+     *
+     * <p><em>Note:</em> Prior to Android 3.0 the property animation APIs did not exist.
+     * As a result, setting a PageTransformer prior to Android 3.0 (API 11) will have no effect.</p>
+     *
+     * @param reverseDrawingOrder true if the supplied PageTransformer requires page views
+     *                            to be drawn from last to first instead of first to last.
+     * @param transformer PageTransformer that will modify each page's animation properties
+     */
+    public void setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer) {
+        final boolean hasTransformer = transformer != null;
+        final boolean needsPopulate = hasTransformer != (mPageTransformer != null);
+        mPageTransformer = transformer;
+        setChildrenDrawingOrderEnabledCompat(hasTransformer);
+        if (hasTransformer) {
+            mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;
+        } else {
+            mDrawingOrder = DRAW_ORDER_DEFAULT;
+        }
+        if (needsPopulate) populate();
+    }
+
+    void setChildrenDrawingOrderEnabledCompat(boolean enable) {
+        if (Build.VERSION.SDK_INT >= 7) {
+            if (mSetChildrenDrawingOrderEnabled == null) {
+                try {
+                    mSetChildrenDrawingOrderEnabled = ViewGroup.class.getDeclaredMethod(
+                            "setChildrenDrawingOrderEnabled", new Class[] { Boolean.TYPE });
+                } catch (NoSuchMethodException e) {
+                    Log.e(TAG, "Can't find setChildrenDrawingOrderEnabled", e);
+                }
+            }
+            try {
+                mSetChildrenDrawingOrderEnabled.invoke(this, enable);
+            } catch (Exception e) {
+                Log.e(TAG, "Error changing children drawing order", e);
+            }
+        }
+    }
+
+    @Override
+    protected int getChildDrawingOrder(int childCount, int i) {
+        final int index = mDrawingOrder == DRAW_ORDER_REVERSE ? childCount - 1 - i : i;
+        final int result = ((LayoutParams) mDrawingOrderedChildren.get(index).getLayoutParams()).childIndex;
+        return result;
+    }
+
+    /**
+     * Set a separate OnPageChangeListener for internal use by the support library.
+     *
+     * @param listener Listener to set
+     * @return The old listener that was set, if any.
+     */
+    OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener) {
+        OnPageChangeListener oldListener = mInternalPageChangeListener;
+        mInternalPageChangeListener = listener;
+        return oldListener;
+    }
+
+    /**
+     * Returns the number of pages that will be retained to either side of the
+     * current page in the view hierarchy in an idle state. Defaults to 1.
+     *
+     * @return How many pages will be kept offscreen on either side
+     * @see #setOffscreenPageLimit(int)
+     */
+    public int getOffscreenPageLimit() {
+        return mOffscreenPageLimit;
+    }
+
+    /**
+     * Set the number of pages that should be retained to either side of the
+     * current page in the view hierarchy in an idle state. Pages beyond this
+     * limit will be recreated from the adapter when needed.
+     *
+     * <p>This is offered as an optimization. If you know in advance the number
+     * of pages you will need to support or have lazy-loading mechanisms in place
+     * on your pages, tweaking this setting can have benefits in perceived smoothness
+     * of paging animations and interaction. If you have a small number of pages (3-4)
+     * that you can keep active all at once, less time will be spent in layout for
+     * newly created view subtrees as the user pages back and forth.</p>
+     *
+     * <p>You should keep this limit low, especially if your pages have complex layouts.
+     * This setting defaults to 1.</p>
+     *
+     * @param limit How many pages will be kept offscreen in an idle state.
+     */
+    public void setOffscreenPageLimit(int limit) {
+        if (limit < DEFAULT_OFFSCREEN_PAGES) {
+            Log.w(TAG, "Requested offscreen page limit " + limit + " too small; defaulting to " +
+                    DEFAULT_OFFSCREEN_PAGES);
+            limit = DEFAULT_OFFSCREEN_PAGES;
+        }
+        if (limit != mOffscreenPageLimit) {
+            mOffscreenPageLimit = limit;
+            populate();
+        }
+    }
+
+    /**
+     * Set the margin between pages.
+     *
+     * @param marginPixels Distance between adjacent pages in pixels
+     * @see #getPageMargin()
+     * @see #setPageMarginDrawable(Drawable)
+     * @see #setPageMarginDrawable(int)
+     */
+    public void setPageMargin(int marginPixels) {
+        final int oldMargin = mPageMargin;
+        mPageMargin = marginPixels;
+
+        final int width = getWidth();
+        recomputeScrollPosition(width, width, marginPixels, oldMargin);
+
+        requestLayout();
+    }
+
+    /**
+     * Return the margin between pages.
+     *
+     * @return The size of the margin in pixels
+     */
+    public int getPageMargin() {
+        return mPageMargin;
+    }
+
+    /**
+     * Set a drawable that will be used to fill the margin between pages.
+     *
+     * @param d Drawable to display between pages
+     */
+    public void setPageMarginDrawable(Drawable d) {
+        mMarginDrawable = d;
+        if (d != null) refreshDrawableState();
+        setWillNotDraw(d == null);
+        invalidate();
+    }
+
+    /**
+     * Set a drawable that will be used to fill the margin between pages.
+     *
+     * @param resId Resource ID of a drawable to display between pages
+     */
+    public void setPageMarginDrawable(int resId) {
+        setPageMarginDrawable(getContext().getResources().getDrawable(resId));
+    }
+
+    @Override
+    protected boolean verifyDrawable(Drawable who) {
+        return super.verifyDrawable(who) || who == mMarginDrawable;
+    }
+
+    @Override
+    protected void drawableStateChanged() {
+        super.drawableStateChanged();
+        final Drawable d = mMarginDrawable;
+        if (d != null && d.isStateful()) {
+            d.setState(getDrawableState());
+        }
+    }
+
+    // We want the duration of the page snap animation to be influenced by the distance that
+    // the screen has to travel, however, we don't want this duration to be effected in a
+    // purely linear fashion. Instead, we use this method to moderate the effect that the distance
+    // of travel has on the overall snap duration.
+    float distanceInfluenceForSnapDuration(float f) {
+        f -= 0.5f; // center the values about 0.
+        f *= 0.3f * Math.PI / 2.0f;
+        return (float) Math.sin(f);
+    }
+
+    /**
+     * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
+     *
+     * @param x the number of pixels to scroll by on the X axis
+     * @param y the number of pixels to scroll by on the Y axis
+     */
+    void smoothScrollTo(int x, int y) {
+        smoothScrollTo(x, y, 0);
+    }
+
+    /**
+     * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
+     *
+     * @param x the number of pixels to scroll by on the X axis
+     * @param y the number of pixels to scroll by on the Y axis
+     * @param velocity the velocity associated with a fling, if applicable. (0 otherwise)
+     */
+    void smoothScrollTo(int x, int y, int velocity) {
+        if (getChildCount() == 0) {
+            // Nothing to do.
+            setScrollingCacheEnabled(false);
+            return;
+        }
+        int sx = getScrollX();
+        int sy = getScrollY();
+        int dx = x - sx;
+        int dy = y - sy;
+        if (dx == 0 && dy == 0) {
+            completeScroll(false);
+            populate();
+            setScrollState(SCROLL_STATE_IDLE);
+            return;
+        }
+
+        setScrollingCacheEnabled(true);
+        setScrollState(SCROLL_STATE_SETTLING);
+
+        final int width = getClientWidth();
+        final int halfWidth = width / 2;
+        final float distanceRatio = Math.min(1f, 1.0f * Math.abs(dx) / width);
+        final float distance = halfWidth + halfWidth *
+                distanceInfluenceForSnapDuration(distanceRatio);
+
+        int duration = 0;
+        velocity = Math.abs(velocity);
+        if (velocity > 0) {
+            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
+        } else {
+            final float pageWidth = width * mAdapter.getPageWidth(mCurItem);
+            final float pageDelta = (float) Math.abs(dx) / (pageWidth + mPageMargin);
+            duration = (int) ((pageDelta + 1) * 100);
+        }
+        duration = Math.min(duration, MAX_SETTLE_DURATION);
+
+        mScroller.startScroll(sx, sy, dx, dy, duration);
+        ViewCompat.postInvalidateOnAnimation(this);
+    }
+
+    ItemInfo addNewItem(int position, int index) {
+        ItemInfo ii = new ItemInfo();
+        ii.position = position;
+        ii.object = mAdapter.instantiateItem(this, position);
+        ii.widthFactor = mAdapter.getPageWidth(position);
+        if (index < 0 || index >= mItems.size()) {
+            mItems.add(ii);
+        } else {
+            mItems.add(index, ii);
+        }
+        return ii;
+    }
+
+    void dataSetChanged() {
+        // This method only gets called if our observer is attached, so mAdapter is non-null.
+
+        final int adapterCount = mAdapter.getCount();
+        mExpectedAdapterCount = adapterCount;
+        boolean needPopulate = mItems.size() < mOffscreenPageLimit * 2 + 1 &&
+                mItems.size() < adapterCount;
+        int newCurrItem = mCurItem;
+
+        boolean isUpdating = false;
+        for (int i = 0; i < mItems.size(); i++) {
+            final ItemInfo ii = mItems.get(i);
+            final int newPos = mAdapter.getItemPosition(ii.object);
+
+            if (newPos == PagerAdapter.POSITION_UNCHANGED) {
+                continue;
+            }
+
+            if (newPos == PagerAdapter.POSITION_NONE) {
+                mItems.remove(i);
+                i--;
+
+                if (!isUpdating) {
+                    mAdapter.startUpdate(this);
+                    isUpdating = true;
+                }
+
+                mAdapter.destroyItem(this, ii.position, ii.object);
+                needPopulate = true;
+
+                if (mCurItem == ii.position) {
+                    // Keep the current item in the valid range
+                    newCurrItem = Math.max(0, Math.min(mCurItem, adapterCount - 1));
+                    needPopulate = true;
+                }
+                continue;
+            }
+
+            if (ii.position != newPos) {
+                if (ii.position == mCurItem) {
+                    // Our current item changed position. Follow it.
+                    newCurrItem = newPos;
+                }
+
+                ii.position = newPos;
+                needPopulate = true;
+            }
+        }
+
+        if (isUpdating) {
+            mAdapter.finishUpdate(this);
+        }
+
+        Collections.sort(mItems, COMPARATOR);
+
+        if (needPopulate) {
+            // Reset our known page widths; populate will recompute them.
+            final int childCount = getChildCount();
+            for (int i = 0; i < childCount; i++) {
+                final View child = getChildAt(i);
+                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                if (!lp.isDecor) {
+                    lp.widthFactor = 0.f;
+                }
+            }
+
+            setCurrentItemInternal(newCurrItem, false, true);
+            requestLayout();
+        }
+    }
+
+    void populate() {
+        populate(mCurItem);
+    }
+
+    void populate(int newCurrentItem) {
+        ItemInfo oldCurInfo = null;
+        int focusDirection = View.FOCUS_FORWARD;
+        if (mCurItem != newCurrentItem) {
+            focusDirection = mCurItem < newCurrentItem ? View.FOCUS_RIGHT : View.FOCUS_LEFT;
+            oldCurInfo = infoForPosition(mCurItem);
+            mCurItem = newCurrentItem;
+        }
+
+        if (mAdapter == null) {
+            sortChildDrawingOrder();
+            return;
+        }
+
+        // Bail now if we are waiting to populate.  This is to hold off
+        // on creating views from the time the user releases their finger to
+        // fling to a new position until we have finished the scroll to
+        // that position, avoiding glitches from happening at that point.
+        if (mPopulatePending) {
+            if (DEBUG) Log.i(TAG, "populate is pending, skipping for now...");
+            sortChildDrawingOrder();
+            return;
+        }
+
+        // Also, don't populate until we are attached to a window.  This is to
+        // avoid trying to populate before we have restored our view hierarchy
+        // state and conflicting with what is restored.
+        if (getWindowToken() == null) {
+            return;
+        }
+
+        mAdapter.startUpdate(this);
+
+        final int pageLimit = mOffscreenPageLimit;
+        final int startPos = Math.max(0, mCurItem - pageLimit);
+        final int N = mAdapter.getCount();
+        final int endPos = Math.min(N-1, mCurItem + pageLimit);
+
+        if (N != mExpectedAdapterCount) {
+            String resName;
+            try {
+                resName = getResources().getResourceName(getId());
+            } catch (Resources.NotFoundException e) {
+                resName = Integer.toHexString(getId());
+            }
+            throw new IllegalStateException("The application's PagerAdapter changed the adapter's" +
+                    " contents without calling PagerAdapter#notifyDataSetChanged!" +
+                    " Expected adapter item count: " + mExpectedAdapterCount + ", found: " + N +
+                    " Pager id: " + resName +
+                    " Pager class: " + getClass() +
+                    " Problematic adapter: " + mAdapter.getClass());
+        }
+
+        // Locate the currently focused item or add it if needed.
+        int curIndex = -1;
+        ItemInfo curItem = null;
+        for (curIndex = 0; curIndex < mItems.size(); curIndex++) {
+            final ItemInfo ii = mItems.get(curIndex);
+            if (ii.position >= mCurItem) {
+                if (ii.position == mCurItem) curItem = ii;
+                break;
+            }
+        }
+
+        if (curItem == null && N > 0) {
+            curItem = addNewItem(mCurItem, curIndex);
+        }
+
+        // Fill 3x the available width or up to the number of offscreen
+        // pages requested to either side, whichever is larger.
+        // If we have no current item we have no work to do.
+        if (curItem != null) {
+            float extraWidthLeft = 0.f;
+            int itemIndex = curIndex - 1;
+            ItemInfo ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
+            final int clientWidth = getClientWidth();
+            final float leftWidthNeeded = clientWidth <= 0 ? 0 :
+                    2.f - curItem.widthFactor + (float) getPaddingLeft() / (float) clientWidth;
+            for (int pos = mCurItem - 1; pos >= 0; pos--) {
+                if (extraWidthLeft >= leftWidthNeeded && pos < startPos) {
+                    if (ii == null) {
+                        break;
+                    }
+                    if (pos == ii.position && !ii.scrolling) {
+                        mItems.remove(itemIndex);
+                        mAdapter.destroyItem(this, pos, ii.object);
+                        if (DEBUG) {
+                            Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
+                                    " view: " + ((View) ii.object));
+                        }
+                        itemIndex--;
+                        curIndex--;
+                        ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
+                    }
+                } else if (ii != null && pos == ii.position) {
+                    extraWidthLeft += ii.widthFactor;
+                    itemIndex--;
+                    ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
+                } else {
+                    ii = addNewItem(pos, itemIndex + 1);
+                    extraWidthLeft += ii.widthFactor;
+                    curIndex++;
+                    ii = itemIndex >= 0 ? mItems.get(itemIndex) : null;
+                }
+            }
+
+            float extraWidthRight = curItem.widthFactor;
+            itemIndex = curIndex + 1;
+            if (extraWidthRight < 2.f) {
+                ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
+                final float rightWidthNeeded = clientWidth <= 0 ? 0 :
+                        (float) getPaddingRight() / (float) clientWidth + 2.f;
+                for (int pos = mCurItem + 1; pos < N; pos++) {
+                    if (extraWidthRight >= rightWidthNeeded && pos > endPos) {
+                        if (ii == null) {
+                            break;
+                        }
+                        if (pos == ii.position && !ii.scrolling) {
+                            mItems.remove(itemIndex);
+                            mAdapter.destroyItem(this, pos, ii.object);
+                            if (DEBUG) {
+                                Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
+                                        " view: " + ((View) ii.object));
+                            }
+                            ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
+                        }
+                    } else if (ii != null && pos == ii.position) {
+                        extraWidthRight += ii.widthFactor;
+                        itemIndex++;
+                        ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
+                    } else {
+                        ii = addNewItem(pos, itemIndex);
+                        itemIndex++;
+                        extraWidthRight += ii.widthFactor;
+                        ii = itemIndex < mItems.size() ? mItems.get(itemIndex) : null;
+                    }
+                }
+            }
+
+            calculatePageOffsets(curItem, curIndex, oldCurInfo);
+        }
+
+        if (DEBUG) {
+            Log.i(TAG, "Current page list:");
+            for (int i=0; i<mItems.size(); i++) {
+                Log.i(TAG, "#" + i + ": page " + mItems.get(i).position);
+            }
+        }
+
+        mAdapter.setPrimaryItem(this, mCurItem, curItem != null ? curItem.object : null);
+
+        mAdapter.finishUpdate(this);
+
+        // Check width measurement of current pages and drawing sort order.
+        // Update LayoutParams as needed.
+        final int childCount = getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final View child = getChildAt(i);
+            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+            lp.childIndex = i;
+            if (!lp.isDecor && lp.widthFactor == 0.f) {
+                // 0 means requery the adapter for this, it doesn't have a valid width.
+                final ItemInfo ii = infoForChild(child);
+                if (ii != null) {
+                    lp.widthFactor = ii.widthFactor;
+                    lp.position = ii.position;
+                }
+            }
+        }
+        sortChildDrawingOrder();
+
+        if (hasFocus()) {
+            View currentFocused = findFocus();
+            ItemInfo ii = currentFocused != null ? infoForAnyChild(currentFocused) : null;
+            if (ii == null || ii.position != mCurItem) {
+                for (int i=0; i<getChildCount(); i++) {
+                    View child = getChildAt(i);
+                    ii = infoForChild(child);
+                    if (ii != null && ii.position == mCurItem) {
+                        if (child.requestFocus(focusDirection)) {
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void sortChildDrawingOrder() {
+        if (mDrawingOrder != DRAW_ORDER_DEFAULT) {
+            if (mDrawingOrderedChildren == null) {
+                mDrawingOrderedChildren = new ArrayList<View>();
+            } else {
+                mDrawingOrderedChildren.clear();
+            }
+            final int childCount = getChildCount();
+            for (int i = 0; i < childCount; i++) {
+                final View child = getChildAt(i);
+                mDrawingOrderedChildren.add(child);
+            }
+            Collections.sort(mDrawingOrderedChildren, sPositionComparator);
+        }
+    }
+
+    private void calculatePageOffsets(ItemInfo curItem, int curIndex, ItemInfo oldCurInfo) {
+        final int N = mAdapter.getCount();
+        final int width = getClientWidth();
+        final float marginOffset = width > 0 ? (float) mPageMargin / width : 0;
+        // Fix up offsets for later layout.
+        if (oldCurInfo != null) {
+            final int oldCurPosition = oldCurInfo.position;
+            // Base offsets off of oldCurInfo.
+            if (oldCurPosition < curItem.position) {
+                int itemIndex = 0;
+                ItemInfo ii = null;
+                float offset = oldCurInfo.offset + oldCurInfo.widthFactor + marginOffset;
+                for (int pos = oldCurPosition + 1;
+                     pos <= curItem.position && itemIndex < mItems.size(); pos++) {
+                    ii = mItems.get(itemIndex);
+                    while (pos > ii.position && itemIndex < mItems.size() - 1) {
+                        itemIndex++;
+                        ii = mItems.get(itemIndex);
+                    }
+                    while (pos < ii.position) {
+                        // We don't have an item populated for this,
+                        // ask the adapter for an offset.
+                        offset += mAdapter.getPageWidth(pos) + marginOffset;
+                        pos++;
+                    }
+                    ii.offset = offset;
+                    offset += ii.widthFactor + marginOffset;
+                }
+            } else if (oldCurPosition > curItem.position) {
+                int itemIndex = mItems.size() - 1;
+                ItemInfo ii = null;
+                float offset = oldCurInfo.offset;
+                for (int pos = oldCurPosition - 1;
+                     pos >= curItem.position && itemIndex >= 0; pos--) {
+                    ii = mItems.get(itemIndex);
+                    while (pos < ii.position && itemIndex > 0) {
+                        itemIndex--;
+                        ii = mItems.get(itemIndex);
+                    }
+                    while (pos > ii.position) {
+                        // We don't have an item populated for this,
+                        // ask the adapter for an offset.
+                        offset -= mAdapter.getPageWidth(pos) + marginOffset;
+                        pos--;
+                    }
+                    offset -= ii.widthFactor + marginOffset;
+                    ii.offset = offset;
+                }
+            }
+        }
+
+        // Base all offsets off of curItem.
+        final int itemCount = mItems.size();
+        float offset = curItem.offset;
+        int pos = curItem.position - 1;
+        mFirstOffset = curItem.position == 0 ? curItem.offset : -Float.MAX_VALUE;
+        mLastOffset = curItem.position == N - 1 ?
+                curItem.offset + curItem.widthFactor - 1 : Float.MAX_VALUE;
+        // Previous pages
+        for (int i = curIndex - 1; i >= 0; i--, pos--) {
+            final ItemInfo ii = mItems.get(i);
+            while (pos > ii.position) {
+                offset -= mAdapter.getPageWidth(pos--) + marginOffset;
+            }
+            offset -= ii.widthFactor + marginOffset;
+            ii.offset = offset;
+            if (ii.position == 0) mFirstOffset = offset;
+        }
+        offset = curItem.offset + curItem.widthFactor + marginOffset;
+        pos = curItem.position + 1;
+        // Next pages
+        for (int i = curIndex + 1; i < itemCount; i++, pos++) {
+            final ItemInfo ii = mItems.get(i);
+            while (pos < ii.position) {
+                offset += mAdapter.getPageWidth(pos++) + marginOffset;
+            }
+            if (ii.position == N - 1) {
+                mLastOffset = offset + ii.widthFactor - 1;
+            }
+            ii.offset = offset;
+            offset += ii.widthFactor + marginOffset;
+        }
+
+        mNeedCalculatePageOffsets = false;
+    }
+
+    /**
+     * This is the persistent state that is saved by ViewPager.  Only needed
+     * if you are creating a sublass of ViewPager that must save its own
+     * state, in which case it should implement a subclass of this which
+     * contains that state.
+     */
+    public static class SavedState extends BaseSavedState {
+        int position;
+        Parcelable adapterState;
+        ClassLoader loader;
+
+        public SavedState(Parcelable superState) {
+            super(superState);
+        }
+
+        @Override
+        public void writeToParcel(Parcel out, int flags) {
+            super.writeToParcel(out, flags);
+            out.writeInt(position);
+            out.writeParcelable(adapterState, flags);
+        }
+
+        @Override
+        public String toString() {
+            return "FragmentPager.SavedState{"
+                    + Integer.toHexString(System.identityHashCode(this))
+                    + " position=" + position + "}";
+        }
+
+        public static final Parcelable.Creator<SavedState> CREATOR
+                = ParcelableCompat.newCreator(new ParcelableCompatCreatorCallbacks<SavedState>() {
+            @Override
+            public SavedState createFromParcel(Parcel in, ClassLoader loader) {
+                return new SavedState(in, loader);
+            }
+
+            @Override
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        });
+
+        SavedState(Parcel in, ClassLoader loader) {
+            super(in);
+            if (loader == null) {
+                loader = getClass().getClassLoader();
+            }
+            position = in.readInt();
+            adapterState = in.readParcelable(loader);
+            this.loader = loader;
+        }
+    }
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+        Parcelable superState = super.onSaveInstanceState();
+        SavedState ss = new SavedState(superState);
+        ss.position = mCurItem;
+        if (mAdapter != null) {
+            ss.adapterState = mAdapter.saveState();
+        }
+        return ss;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+        if (!(state instanceof SavedState)) {
+            super.onRestoreInstanceState(state);
+            return;
+        }
+
+        SavedState ss = (SavedState)state;
+        super.onRestoreInstanceState(ss.getSuperState());
+
+        if (mAdapter != null) {
+            mAdapter.restoreState(ss.adapterState, ss.loader);
+            setCurrentItemInternal(ss.position, false, true);
+        } else {
+            mRestoredCurItem = ss.position;
+            mRestoredAdapterState = ss.adapterState;
+            mRestoredClassLoader = ss.loader;
+        }
+    }
+
+    @Override
+    public void addView(View child, int index, ViewGroup.LayoutParams params) {
+        if (!checkLayoutParams(params)) {
+            params = generateLayoutParams(params);
+        }
+        final LayoutParams lp = (LayoutParams) params;
+        lp.isDecor |= child instanceof Decor;
+        if (mInLayout) {
+            if (lp != null && lp.isDecor) {
+                throw new IllegalStateException("Cannot add pager decor view during layout");
+            }
+            lp.needsMeasure = true;
+            addViewInLayout(child, index, params);
+        } else {
+            super.addView(child, index, params);
+        }
+
+        if (USE_CACHE) {
+            if (child.getVisibility() != GONE) {
+                child.setDrawingCacheEnabled(mScrollingCacheEnabled);
+            } else {
+                child.setDrawingCacheEnabled(false);
+            }
+        }
+    }
+
+    @Override
+    public void removeView(View view) {
+        if (mInLayout) {
+            removeViewInLayout(view);
+        } else {
+            super.removeView(view);
+        }
+    }
+
+    ItemInfo infoForChild(View child) {
+        for (int i=0; i<mItems.size(); i++) {
+            ItemInfo ii = mItems.get(i);
+            if (mAdapter.isViewFromObject(child, ii.object)) {
+                return ii;
+            }
+        }
+        return null;
+    }
+
+    ItemInfo infoForAnyChild(View child) {
+        ViewParent parent;
+        while ((parent=child.getParent()) != this) {
+            if (parent == null || !(parent instanceof View)) {
+                return null;
+            }
+            child = (View)parent;
+        }
+        return infoForChild(child);
+    }
+
+    ItemInfo infoForPosition(int position) {
+        for (int i = 0; i < mItems.size(); i++) {
+            ItemInfo ii = mItems.get(i);
+            if (ii.position == position) {
+                return ii;
+            }
+        }
+        return null;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        mFirstLayout = true;
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        // For simple implementation, our internal size is always 0.
+        // We depend on the container to specify the layout size of
+        // our view.  We can't really know what it is since we will be
+        // adding and removing different arbitrary views and do not
+        // want the layout to change as this happens.
+        setMeasuredDimension(getDefaultSize(0, widthMeasureSpec),
+                getDefaultSize(0, heightMeasureSpec));
+
+        final int measuredWidth = getMeasuredWidth();
+        final int maxGutterSize = measuredWidth / 10;
+        mGutterSize = Math.min(maxGutterSize, mDefaultGutterSize);
+
+        // Children are just made to fill our space.
+        int childWidthSize = measuredWidth - getPaddingLeft() - getPaddingRight();
+        int childHeightSize = getMeasuredHeight() - getPaddingTop() - getPaddingBottom();
+
+        /*
+         * Make sure all children have been properly measured. Decor views first.
+         * Right now we cheat and make this less complicated by assuming decor
+         * views won't intersect. We will pin to edges based on gravity.
+         */
+        int size = getChildCount();
+        for (int i = 0; i < size; ++i) {
+            final View child = getChildAt(i);
+            if (child.getVisibility() != GONE) {
+                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                if (lp != null && lp.isDecor) {
+                    final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
+                    final int vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
+                    int widthMode = MeasureSpec.AT_MOST;
+                    int heightMode = MeasureSpec.AT_MOST;
+                    boolean consumeVertical = vgrav == Gravity.TOP || vgrav == Gravity.BOTTOM;
+                    boolean consumeHorizontal = hgrav == Gravity.LEFT || hgrav == Gravity.RIGHT;
+
+                    if (consumeVertical) {
+                        widthMode = MeasureSpec.EXACTLY;
+                    } else if (consumeHorizontal) {
+                        heightMode = MeasureSpec.EXACTLY;
+                    }
+
+                    int widthSize = childWidthSize;
+                    int heightSize = childHeightSize;
+                    if (lp.width != LayoutParams.WRAP_CONTENT) {
+                        widthMode = MeasureSpec.EXACTLY;
+                        if (lp.width != LayoutParams.FILL_PARENT) {
+                            widthSize = lp.width;
+                        }
+                    }
+                    if (lp.height != LayoutParams.WRAP_CONTENT) {
+                        heightMode = MeasureSpec.EXACTLY;
+                        if (lp.height != LayoutParams.FILL_PARENT) {
+                            heightSize = lp.height;
+                        }
+                    }
+                    final int widthSpec = MeasureSpec.makeMeasureSpec(widthSize, widthMode);
+                    final int heightSpec = MeasureSpec.makeMeasureSpec(heightSize, heightMode);
+                    child.measure(widthSpec, heightSpec);
+
+                    if (consumeVertical) {
+                        childHeightSize -= child.getMeasuredHeight();
+                    } else if (consumeHorizontal) {
+                        childWidthSize -= child.getMeasuredWidth();
+                    }
+                }
+            }
+        }
+
+        mChildWidthMeasureSpec = MeasureSpec.makeMeasureSpec(childWidthSize, MeasureSpec.EXACTLY);
+        mChildHeightMeasureSpec = MeasureSpec.makeMeasureSpec(childHeightSize, MeasureSpec.EXACTLY);
+
+        // Make sure we have created all fragments that we need to have shown.
+        mInLayout = true;
+        populate();
+        mInLayout = false;
+
+        // Page views next.
+        size = getChildCount();
+        for (int i = 0; i < size; ++i) {
+            final View child = getChildAt(i);
+            if (child.getVisibility() != GONE) {
+                if (DEBUG) Log.v(TAG, "Measuring #" + i + " " + child
+                        + ": " + mChildWidthMeasureSpec);
+
+                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                if (lp == null || !lp.isDecor) {
+                    final int widthSpec = MeasureSpec.makeMeasureSpec(
+                            (int) (childWidthSize * lp.widthFactor), MeasureSpec.EXACTLY);
+                    child.measure(widthSpec, mChildHeightMeasureSpec);
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+
+        // Make sure scroll position is set correctly.
+        if (w != oldw) {
+            recomputeScrollPosition(w, oldw, mPageMargin, mPageMargin);
+        }
+    }
+
+    private void recomputeScrollPosition(int width, int oldWidth, int margin, int oldMargin) {
+        if (oldWidth > 0 && !mItems.isEmpty()) {
+            final int widthWithMargin = width - getPaddingLeft() - getPaddingRight() + margin;
+            final int oldWidthWithMargin = oldWidth - getPaddingLeft() - getPaddingRight()
+                    + oldMargin;
+            final int xpos = getScrollX();
+            final float pageOffset = (float) xpos / oldWidthWithMargin;
+            final int newOffsetPixels = (int) (pageOffset * widthWithMargin);
+
+            scrollTo(newOffsetPixels, getScrollY());
+            if (!mScroller.isFinished()) {
+                // We now return to your regularly scheduled scroll, already in progress.
+                final int newDuration = mScroller.getDuration() - mScroller.timePassed();
+                ItemInfo targetInfo = infoForPosition(mCurItem);
+                mScroller.startScroll(newOffsetPixels, 0,
+                        (int) (targetInfo.offset * width), 0, newDuration);
+            }
+        } else {
+            final ItemInfo ii = infoForPosition(mCurItem);
+            final float scrollOffset = ii != null ? Math.min(ii.offset, mLastOffset) : 0;
+            final int scrollPos = (int) (scrollOffset *
+                    (width - getPaddingLeft() - getPaddingRight()));
+            if (scrollPos != getScrollX()) {
+                completeScroll(false);
+                scrollTo(scrollPos, getScrollY());
+            }
+        }
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        final int count = getChildCount();
+        int width = r - l;
+        int height = b - t;
+        int paddingLeft = getPaddingLeft();
+        int paddingTop = getPaddingTop();
+        int paddingRight = getPaddingRight();
+        int paddingBottom = getPaddingBottom();
+        final int scrollX = getScrollX();
+
+        int decorCount = 0;
+
+        // First pass - decor views. We need to do this in two passes so that
+        // we have the proper offsets for non-decor views later.
+        for (int i = 0; i < count; i++) {
+            final View child = getChildAt(i);
+            if (child.getVisibility() != GONE) {
+                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                int childLeft = 0;
+                int childTop = 0;
+                if (lp.isDecor) {
+                    final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
+                    final int vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
+                    switch (hgrav) {
+                        default:
+                            childLeft = paddingLeft;
+                            break;
+                        case Gravity.LEFT:
+                            childLeft = paddingLeft;
+                            paddingLeft += child.getMeasuredWidth();
+                            break;
+                        case Gravity.CENTER_HORIZONTAL:
+                            childLeft = Math.max((width - child.getMeasuredWidth()) / 2,
+                                    paddingLeft);
+                            break;
+                        case Gravity.RIGHT:
+                            childLeft = width - paddingRight - child.getMeasuredWidth();
+                            paddingRight += child.getMeasuredWidth();
+                            break;
+                    }
+                    switch (vgrav) {
+                        default:
+                            childTop = paddingTop;
+                            break;
+                        case Gravity.TOP:
+                            childTop = paddingTop;
+                            paddingTop += child.getMeasuredHeight();
+                            break;
+                        case Gravity.CENTER_VERTICAL:
+                            childTop = Math.max((height - child.getMeasuredHeight()) / 2,
+                                    paddingTop);
+                            break;
+                        case Gravity.BOTTOM:
+                            childTop = height - paddingBottom - child.getMeasuredHeight();
+                            paddingBottom += child.getMeasuredHeight();
+                            break;
+                    }
+                    childLeft += scrollX;
+                    child.layout(childLeft, childTop,
+                            childLeft + child.getMeasuredWidth(),
+                            childTop + child.getMeasuredHeight());
+                    decorCount++;
+                }
+            }
+        }
+
+        final int childWidth = width - paddingLeft - paddingRight;
+        // Page views. Do this once we have the right padding offsets from above.
+        for (int i = 0; i < count; i++) {
+            final View child = getChildAt(i);
+            if (child.getVisibility() != GONE) {
+                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                ItemInfo ii;
+                if (!lp.isDecor && (ii = infoForChild(child)) != null) {
+                    int loff = (int) (childWidth * ii.offset);
+                    int childLeft = paddingLeft + loff;
+                    int childTop = paddingTop;
+                    if (lp.needsMeasure) {
+                        // This was added during layout and needs measurement.
+                        // Do it now that we know what we're working with.
+                        lp.needsMeasure = false;
+                        final int widthSpec = MeasureSpec.makeMeasureSpec(
+                                (int) (childWidth * lp.widthFactor),
+                                MeasureSpec.EXACTLY);
+                        final int heightSpec = MeasureSpec.makeMeasureSpec(
+                                (int) (height - paddingTop - paddingBottom),
+                                MeasureSpec.EXACTLY);
+                        child.measure(widthSpec, heightSpec);
+                    }
+                    if (DEBUG) Log.v(TAG, "Positioning #" + i + " " + child + " f=" + ii.object
+                            + ":" + childLeft + "," + childTop + " " + child.getMeasuredWidth()
+                            + "x" + child.getMeasuredHeight());
+                    child.layout(childLeft, childTop,
+                            childLeft + child.getMeasuredWidth(),
+                            childTop + child.getMeasuredHeight());
+                }
+            }
+        }
+        mTopPageBounds = paddingTop;
+        mBottomPageBounds = height - paddingBottom;
+        mDecorChildCount = decorCount;
+
+        if (mFirstLayout) {
+            scrollToItem(mCurItem, false, 0, false);
+        }
+        mFirstLayout = false;
+    }
+
+    @Override
+    public void computeScroll() {
+        if (!mScroller.isFinished() && mScroller.computeScrollOffset()) {
+            int oldX = getScrollX();
+            int oldY = getScrollY();
+            int x = mScroller.getCurrX();
+            int y = mScroller.getCurrY();
+
+            if (oldX != x || oldY != y) {
+                scrollTo(x, y);
+                if (!pageScrolled(x)) {
+                    mScroller.abortAnimation();
+                    scrollTo(0, y);
+                }
+            }
+
+            // Keep on drawing until the animation has finished.
+            ViewCompat.postInvalidateOnAnimation(this);
+            return;
+        }
+
+        // Done with scroll, clean up state.
+        completeScroll(true);
+    }
+
+    private boolean pageScrolled(int xpos) {
+        if (mItems.size() == 0) {
+            mCalledSuper = false;
+            onPageScrolled(0, 0, 0);
+            if (!mCalledSuper) {
+                throw new IllegalStateException(
+                        "onPageScrolled did not call superclass implementation");
+            }
+            return false;
+        }
+        final ItemInfo ii = infoForCurrentScrollPosition();
+        final int width = getClientWidth();
+        final int widthWithMargin = width + mPageMargin;
+        final float marginOffset = (float) mPageMargin / width;
+        final int currentPage = ii.position;
+        final float pageOffset = (((float) xpos / width) - ii.offset) /
+                (ii.widthFactor + marginOffset);
+        final int offsetPixels = (int) (pageOffset * widthWithMargin);
+
+        mCalledSuper = false;
+        onPageScrolled(currentPage, pageOffset, offsetPixels);
+        if (!mCalledSuper) {
+            throw new IllegalStateException(
+                    "onPageScrolled did not call superclass implementation");
+        }
+        return true;
+    }
+
+    /**
+     * This method will be invoked when the current page is scrolled, either as part
+     * of a programmatically initiated smooth scroll or a user initiated touch scroll.
+     * If you override this method you must call through to the superclass implementation
+     * (e.g. super.onPageScrolled(position, offset, offsetPixels)) before onPageScrolled
+     * returns.
+     *
+     * @param position Position index of the first page currently being displayed.
+     *                 Page position+1 will be visible if positionOffset is nonzero.
+     * @param offset Value from [0, 1) indicating the offset from the page at position.
+     * @param offsetPixels Value in pixels indicating the offset from position.
+     */
+    protected void onPageScrolled(int position, float offset, int offsetPixels) {
+        // Offset any decor views if needed - keep them on-screen at all times.
+        if (mDecorChildCount > 0) {
+            final int scrollX = getScrollX();
+            int paddingLeft = getPaddingLeft();
+            int paddingRight = getPaddingRight();
+            final int width = getWidth();
+            final int childCount = getChildCount();
+            for (int i = 0; i < childCount; i++) {
+                final View child = getChildAt(i);
+                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                if (!lp.isDecor) continue;
+
+                final int hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
+                int childLeft = 0;
+                switch (hgrav) {
+                    default:
+                        childLeft = paddingLeft;
+                        break;
+                    case Gravity.LEFT:
+                        childLeft = paddingLeft;
+                        paddingLeft += child.getWidth();
+                        break;
+                    case Gravity.CENTER_HORIZONTAL:
+                        childLeft = Math.max((width - child.getMeasuredWidth()) / 2,
+                                paddingLeft);
+                        break;
+                    case Gravity.RIGHT:
+                        childLeft = width - paddingRight - child.getMeasuredWidth();
+                        paddingRight += child.getMeasuredWidth();
+                        break;
+                }
+                childLeft += scrollX;
+
+                final int childOffset = childLeft - child.getLeft();
+                if (childOffset != 0) {
+                    child.offsetLeftAndRight(childOffset);
+                }
+            }
+        }
+        for (OnPageChangeListener eachListener : mOnPageChangeListeners) {
+            if (eachListener != null) {
+                eachListener.onPageScrolled(position, offset, offsetPixels);
+            }
+        }
+        if (mInternalPageChangeListener != null) {
+            mInternalPageChangeListener.onPageScrolled(position, offset, offsetPixels);
+        }
+
+        if (mPageTransformer != null) {
+            final int scrollX = getScrollX();
+            final int childCount = getChildCount();
+            for (int i = 0; i < childCount; i++) {
+                final View child = getChildAt(i);
+                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+
+                if (lp.isDecor) continue;
+
+                final float transformPos = (float) (child.getLeft() - scrollX) / getClientWidth();
+                mPageTransformer.transformPage(child, transformPos);
+            }
+        }
+
+        mCalledSuper = true;
+    }
+
+    private void completeScroll(boolean postEvents) {
+        boolean needPopulate = mScrollState == SCROLL_STATE_SETTLING;
+        if (needPopulate) {
+            // Done with scroll, no longer want to cache view drawing.
+            setScrollingCacheEnabled(false);
+            mScroller.abortAnimation();
+            int oldX = getScrollX();
+            int oldY = getScrollY();
+            int x = mScroller.getCurrX();
+            int y = mScroller.getCurrY();
+            if (oldX != x || oldY != y) {
+                scrollTo(x, y);
+            }
+        }
+        mPopulatePending = false;
+        for (int i=0; i<mItems.size(); i++) {
+            ItemInfo ii = mItems.get(i);
+            if (ii.scrolling) {
+                needPopulate = true;
+                ii.scrolling = false;
+            }
+        }
+        if (needPopulate) {
+            if (postEvents) {
+                ViewCompat.postOnAnimation(this, mEndScrollRunnable);
+            } else {
+                mEndScrollRunnable.run();
+            }
+        }
+    }
+
+    private boolean isGutterDrag(float x, float dx) {
+        return (x < mGutterSize && dx > 0) || (x > getWidth() - mGutterSize && dx < 0);
+    }
+
+    private void enableLayers(boolean enable) {
+        final int childCount = getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final int layerType = enable ?
+                    ViewCompat.LAYER_TYPE_HARDWARE : ViewCompat.LAYER_TYPE_NONE;
+            ViewCompat.setLayerType(getChildAt(i), layerType, null);
+        }
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent ev) {
+        /*
+         * This method JUST determines whether we want to intercept the motion.
+         * If we return true, onMotionEvent will be called and we do the actual
+         * scrolling there.
+         */
+
+        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
+
+        // Always take care of the touch gesture being complete.
+        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
+            // Release the drag.
+            if (DEBUG) Log.v(TAG, "Intercept done!");
+            mIsBeingDragged = false;
+            mIsUnableToDrag = false;
+            mActivePointerId = INVALID_POINTER;
+            if (mVelocityTracker != null) {
+                mVelocityTracker.recycle();
+                mVelocityTracker = null;
+            }
+            return false;
+        }
+
+        // Nothing more to do here if we have decided whether or not we
+        // are dragging.
+        if (action != MotionEvent.ACTION_DOWN) {
+            if (mIsBeingDragged) {
+                if (DEBUG) Log.v(TAG, "Intercept returning true!");
+                return true;
+            }
+            if (mIsUnableToDrag) {
+                if (DEBUG) Log.v(TAG, "Intercept returning false!");
+                return false;
+            }
+        }
+
+        switch (action) {
+            case MotionEvent.ACTION_MOVE: {
+                /*
+                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
+                 * whether the user has moved far enough from his original down touch.
+                 */
+
+                /*
+                * Locally do absolute value. mLastMotionY is set to the y value
+                * of the down event.
+                */
+                final int activePointerId = mActivePointerId;
+                if (activePointerId == INVALID_POINTER) {
+                    // If we don't have a valid id, the touch down wasn't on content.
+                    break;
+                }
+
+                final int pointerIndex = MotionEventCompat.findPointerIndex(ev, activePointerId);
+                final float x = MotionEventCompat.getX(ev, pointerIndex);
+                final float dx = x - mLastMotionX;
+                final float xDiff = Math.abs(dx);
+                final float y = MotionEventCompat.getY(ev, pointerIndex);
+                final float yDiff = Math.abs(y - mInitialMotionY);
+                if (DEBUG) Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);
+
+                if (dx != 0 && !isGutterDrag(mLastMotionX, dx) &&
+                        canScroll(this, false, (int) dx, (int) x, (int) y)) {
+                    // Nested view has scrollable area under this point. Let it be handled there.
+                    mLastMotionX = x;
+                    mLastMotionY = y;
+                    mIsUnableToDrag = true;
+                    return false;
+                }
+                if (xDiff > mTouchSlop && xDiff * 0.5f > yDiff) {
+                    if (DEBUG) Log.v(TAG, "Starting drag!");
+                    mIsBeingDragged = true;
+                    requestParentDisallowInterceptTouchEvent(true);
+                    setScrollState(SCROLL_STATE_DRAGGING);
+                    mLastMotionX = dx > 0 ? mInitialMotionX + mTouchSlop :
+                            mInitialMotionX - mTouchSlop;
+                    mLastMotionY = y;
+                    setScrollingCacheEnabled(true);
+                } else if (yDiff > mTouchSlop) {
+                    // The finger has moved enough in the vertical
+                    // direction to be counted as a drag...  abort
+                    // any attempt to drag horizontally, to work correctly
+                    // with children that have scrolling containers.
+                    if (DEBUG) Log.v(TAG, "Starting unable to drag!");
+                    mIsUnableToDrag = true;
+                }
+                if (mIsBeingDragged) {
+                    // Scroll to follow the motion event
+                    if (performDrag(x)) {
+                        ViewCompat.postInvalidateOnAnimation(this);
+                    }
+                }
+                break;
+            }
+
+            case MotionEvent.ACTION_DOWN: {
+                /*
+                 * Remember location of down touch.
+                 * ACTION_DOWN always refers to pointer index 0.
+                 */
+                mLastMotionX = mInitialMotionX = ev.getX();
+                mLastMotionY = mInitialMotionY = ev.getY();
+                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
+                mIsUnableToDrag = false;
+
+                mScroller.computeScrollOffset();
+                if (mScrollState == SCROLL_STATE_SETTLING &&
+                        Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) > mCloseEnough) {
+                    // Let the user 'catch' the pager as it animates.
+                    mScroller.abortAnimation();
+                    mPopulatePending = false;
+                    populate();
+                    mIsBeingDragged = true;
+                    requestParentDisallowInterceptTouchEvent(true);
+                    setScrollState(SCROLL_STATE_DRAGGING);
+                } else {
+                    completeScroll(false);
+                    mIsBeingDragged = false;
+                }
+
+                if (DEBUG) Log.v(TAG, "Down at " + mLastMotionX + "," + mLastMotionY
+                        + " mIsBeingDragged=" + mIsBeingDragged
+                        + "mIsUnableToDrag=" + mIsUnableToDrag);
+                break;
+            }
+
+            case MotionEventCompat.ACTION_POINTER_UP:
+                onSecondaryPointerUp(ev);
+                break;
+        }
+
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(ev);
+
+        /*
+         * The only time we want to intercept motion events is if we are in the
+         * drag mode.
+         */
+        return mIsBeingDragged;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+        if (mFakeDragging) {
+            // A fake drag is in progress already, ignore this real one
+            // but still eat the touch events.
+            // (It is likely that the user is multi-touching the screen.)
+            return true;
+        }
+
+        if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
+            // Don't handle edge touches immediately -- they may actually belong to one of our
+            // descendants.
+            return false;
+        }
+
+        if (mAdapter == null || mAdapter.getCount() == 0) {
+            // Nothing to present or scroll; nothing to touch.
+            return false;
+        }
+
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(ev);
+
+        final int action = ev.getAction();
+        boolean needsInvalidate = false;
+
+        switch (action & MotionEventCompat.ACTION_MASK) {
+            case MotionEvent.ACTION_DOWN: {
+                mScroller.abortAnimation();
+                mPopulatePending = false;
+                populate();
+
+                // Remember where the motion event started
+                mLastMotionX = mInitialMotionX = ev.getX();
+                mLastMotionY = mInitialMotionY = ev.getY();
+                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);
+                break;
+            }
+            case MotionEvent.ACTION_MOVE:
+                if (!mIsBeingDragged) {
+                    final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
+                    final float x = MotionEventCompat.getX(ev, pointerIndex);
+                    final float xDiff = Math.abs(x - mLastMotionX);
+                    final float y = MotionEventCompat.getY(ev, pointerIndex);
+                    final float yDiff = Math.abs(y - mLastMotionY);
+                    if (DEBUG) Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);
+                    if (xDiff > mTouchSlop && xDiff > yDiff) {
+                        if (DEBUG) Log.v(TAG, "Starting drag!");
+                        mIsBeingDragged = true;
+                        requestParentDisallowInterceptTouchEvent(true);
+                        mLastMotionX = x - mInitialMotionX > 0 ? mInitialMotionX + mTouchSlop :
+                                mInitialMotionX - mTouchSlop;
+                        mLastMotionY = y;
+                        setScrollState(SCROLL_STATE_DRAGGING);
+                        setScrollingCacheEnabled(true);
+
+                        // Disallow Parent Intercept, just in case
+                        ViewParent parent = getParent();
+                        if (parent != null) {
+                            parent.requestDisallowInterceptTouchEvent(true);
+                        }
+                    }
+                }
+                // Not else! Note that mIsBeingDragged can be set above.
+                if (mIsBeingDragged) {
+                    // Scroll to follow the motion event
+                    final int activePointerIndex = MotionEventCompat.findPointerIndex(
+                            ev, mActivePointerId);
+                    final float x = MotionEventCompat.getX(ev, activePointerIndex);
+                    needsInvalidate |= performDrag(x);
+                }
+                break;
+            case MotionEvent.ACTION_UP:
+                if (mIsBeingDragged) {
+                    final VelocityTracker velocityTracker = mVelocityTracker;
+                    velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
+                    int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(
+                            velocityTracker, mActivePointerId);
+                    mPopulatePending = true;
+                    final int width = getClientWidth();
+                    final int scrollX = getScrollX();
+                    final ItemInfo ii = infoForCurrentScrollPosition();
+                    final int currentPage = ii.position;
+                    final float pageOffset = (((float) scrollX / width) - ii.offset) / ii.widthFactor;
+                    final int activePointerIndex =
+                            MotionEventCompat.findPointerIndex(ev, mActivePointerId);
+                    final float x = MotionEventCompat.getX(ev, activePointerIndex);
+                    final int totalDelta = (int) (x - mInitialMotionX);
+                    int nextPage = determineTargetPage(currentPage, pageOffset, initialVelocity,
+                            totalDelta);
+                    setCurrentItemInternal(nextPage, true, true, initialVelocity);
+
+                    mActivePointerId = INVALID_POINTER;
+                    endDrag();
+                    needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();
+                }
+                break;
+            case MotionEvent.ACTION_CANCEL:
+                if (mIsBeingDragged) {
+                    scrollToItem(mCurItem, true, 0, false);
+                    mActivePointerId = INVALID_POINTER;
+                    endDrag();
+                    needsInvalidate = mLeftEdge.onRelease() | mRightEdge.onRelease();
+                }
+                break;
+            case MotionEventCompat.ACTION_POINTER_DOWN: {
+                final int index = MotionEventCompat.getActionIndex(ev);
+                final float x = MotionEventCompat.getX(ev, index);
+                mLastMotionX = x;
+                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
+                break;
+            }
+            case MotionEventCompat.ACTION_POINTER_UP:
+                onSecondaryPointerUp(ev);
+                mLastMotionX = MotionEventCompat.getX(ev,
+                        MotionEventCompat.findPointerIndex(ev, mActivePointerId));
+                break;
+        }
+        if (needsInvalidate) {
+            ViewCompat.postInvalidateOnAnimation(this);
+        }
+        return true;
+    }
+
+    private void requestParentDisallowInterceptTouchEvent(boolean disallowIntercept) {
+        final ViewParent parent = getParent();
+        if (parent != null) {
+            parent.requestDisallowInterceptTouchEvent(disallowIntercept);
+        }
+    }
+
+    private boolean performDrag(float x) {
+        boolean needsInvalidate = false;
+
+        final float deltaX = mLastMotionX - x;
+        mLastMotionX = x;
+
+        float oldScrollX = getScrollX();
+        float scrollX = oldScrollX + deltaX;
+        final int width = getClientWidth();
+
+        float leftBound = width * mFirstOffset;
+        float rightBound = width * mLastOffset;
+        boolean leftAbsolute = true;
+        boolean rightAbsolute = true;
+
+        final ItemInfo firstItem = mItems.get(0);
+        final ItemInfo lastItem = mItems.get(mItems.size() - 1);
+        if (firstItem.position != 0) {
+            leftAbsolute = false;
+            leftBound = firstItem.offset * width;
+        }
+        if (lastItem.position != mAdapter.getCount() - 1) {
+            rightAbsolute = false;
+            rightBound = lastItem.offset * width;
+        }
+
+        if (scrollX < leftBound) {
+            if (leftAbsolute) {
+                float over = leftBound - scrollX;
+                needsInvalidate = mLeftEdge.onPull(Math.abs(over) / width);
+            }
+            scrollX = leftBound;
+        } else if (scrollX > rightBound) {
+            if (rightAbsolute) {
+                float over = scrollX - rightBound;
+                needsInvalidate = mRightEdge.onPull(Math.abs(over) / width);
+            }
+            scrollX = rightBound;
+        }
+        // Don't lose the rounded component
+        mLastMotionX += scrollX - (int) scrollX;
+        scrollTo((int) scrollX, getScrollY());
+        pageScrolled((int) scrollX);
+
+        return needsInvalidate;
+    }
+
+    /**
+     * @return Info about the page at the current scroll position.
+     *         This can be synthetic for a missing middle page; the 'object' field can be null.
+     */
+    private ItemInfo infoForCurrentScrollPosition() {
+        final int width = getClientWidth();
+        final float scrollOffset = width > 0 ? (float) getScrollX() / width : 0;
+        final float marginOffset = width > 0 ? (float) mPageMargin / width : 0;
+        int lastPos = -1;
+        float lastOffset = 0.f;
+        float lastWidth = 0.f;
+        boolean first = true;
+
+        ItemInfo lastItem = null;
+        for (int i = 0; i < mItems.size(); i++) {
+            ItemInfo ii = mItems.get(i);
+            float offset;
+            if (!first && ii.position != lastPos + 1) {
+                // Create a synthetic item for a missing page.
+                ii = mTempItem;
+                ii.offset = lastOffset + lastWidth + marginOffset;
+                ii.position = lastPos + 1;
+                ii.widthFactor = mAdapter.getPageWidth(ii.position);
+                i--;
+            }
+            offset = ii.offset;
+
+            final float leftBound = offset;
+            final float rightBound = offset + ii.widthFactor + marginOffset;
+            if (first || scrollOffset >= leftBound) {
+                if (scrollOffset < rightBound || i == mItems.size() - 1) {
+                    return ii;
+                }
+            } else {
+                return lastItem;
+            }
+            first = false;
+            lastPos = ii.position;
+            lastOffset = offset;
+            lastWidth = ii.widthFactor;
+            lastItem = ii;
+        }
+
+        return lastItem;
+    }
+
+    private int determineTargetPage(int currentPage, float pageOffset, int velocity, int deltaX) {
+        int targetPage;
+        if (Math.abs(deltaX) > mFlingDistance && Math.abs(velocity) > mMinimumVelocity) {
+            targetPage = velocity > 0 ? currentPage : currentPage + 1;
+        } else {
+            final float truncator = currentPage >= mCurItem ? 0.4f : 0.6f;
+            targetPage = (int) (currentPage + pageOffset + truncator);
+        }
+
+        if (mItems.size() > 0) {
+            final ItemInfo firstItem = mItems.get(0);
+            final ItemInfo lastItem = mItems.get(mItems.size() - 1);
+
+            // Only let the user target pages we have items for
+            targetPage = Math.max(firstItem.position, Math.min(targetPage, lastItem.position));
+        }
+
+        return targetPage;
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        super.draw(canvas);
+        boolean needsInvalidate = false;
+
+        final int overScrollMode = ViewCompat.getOverScrollMode(this);
+        if (overScrollMode == ViewCompat.OVER_SCROLL_ALWAYS ||
+                (overScrollMode == ViewCompat.OVER_SCROLL_IF_CONTENT_SCROLLS &&
+                        mAdapter != null && mAdapter.getCount() > 1)) {
+            if (!mLeftEdge.isFinished()) {
+                final int restoreCount = canvas.save();
+                final int height = getHeight() - getPaddingTop() - getPaddingBottom();
+                final int width = getWidth();
+
+                canvas.rotate(270);
+                canvas.translate(-height + getPaddingTop(), mFirstOffset * width);
+                mLeftEdge.setSize(height, width);
+                needsInvalidate |= mLeftEdge.draw(canvas);
+                canvas.restoreToCount(restoreCount);
+            }
+            if (!mRightEdge.isFinished()) {
+                final int restoreCount = canvas.save();
+                final int width = getWidth();
+                final int height = getHeight() - getPaddingTop() - getPaddingBottom();
+
+                canvas.rotate(90);
+                canvas.translate(-getPaddingTop(), -(mLastOffset + 1) * width);
+                mRightEdge.setSize(height, width);
+                needsInvalidate |= mRightEdge.draw(canvas);
+                canvas.restoreToCount(restoreCount);
+            }
+        } else {
+            mLeftEdge.finish();
+            mRightEdge.finish();
+        }
+
+        if (needsInvalidate) {
+            // Keep animating
+            ViewCompat.postInvalidateOnAnimation(this);
+        }
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        // Draw the margin drawable between pages if needed.
+        if (mPageMargin > 0 && mMarginDrawable != null && mItems.size() > 0 && mAdapter != null) {
+            final int scrollX = getScrollX();
+            final int width = getWidth();
+
+            final float marginOffset = (float) mPageMargin / width;
+            int itemIndex = 0;
+            ItemInfo ii = mItems.get(0);
+            float offset = ii.offset;
+            final int itemCount = mItems.size();
+            final int firstPos = ii.position;
+            final int lastPos = mItems.get(itemCount - 1).position;
+            for (int pos = firstPos; pos < lastPos; pos++) {
+                while (pos > ii.position && itemIndex < itemCount) {
+                    ii = mItems.get(++itemIndex);
+                }
+
+                float drawAt;
+                if (pos == ii.position) {
+                    drawAt = (ii.offset + ii.widthFactor) * width;
+                    offset = ii.offset + ii.widthFactor + marginOffset;
+                } else {
+                    float widthFactor = mAdapter.getPageWidth(pos);
+                    drawAt = (offset + widthFactor) * width;
+                    offset += widthFactor + marginOffset;
+                }
+
+                if (drawAt + mPageMargin > scrollX) {
+                    mMarginDrawable.setBounds((int) drawAt, mTopPageBounds,
+                            (int) (drawAt + mPageMargin + 0.5f), mBottomPageBounds);
+                    mMarginDrawable.draw(canvas);
+                }
+
+                if (drawAt > scrollX + width) {
+                    break; // No more visible, no sense in continuing
+                }
+            }
+        }
+    }
+
+    /**
+     * Start a fake drag of the pager.
+     *
+     * <p>A fake drag can be useful if you want to synchronize the motion of the ViewPager
+     * with the touch scrolling of another view, while still letting the ViewPager
+     * control the snapping motion and fling behavior. (e.g. parallax-scrolling tabs.)
+     * Call {@link #fakeDragBy(float)} to simulate the actual drag motion. Call
+     * {@link #endFakeDrag()} to complete the fake drag and fling as necessary.
+     *
+     * <p>During a fake drag the ViewPager will ignore all touch events. If a real drag
+     * is already in progress, this method will return false.
+     *
+     * @return true if the fake drag began successfully, false if it could not be started.
+     *
+     * @see #fakeDragBy(float)
+     * @see #endFakeDrag()
+     */
+    public boolean beginFakeDrag() {
+        if (mIsBeingDragged) {
+            return false;
+        }
+        mFakeDragging = true;
+        setScrollState(SCROLL_STATE_DRAGGING);
+        mInitialMotionX = mLastMotionX = 0;
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        } else {
+            mVelocityTracker.clear();
+        }
+        final long time = SystemClock.uptimeMillis();
+        final MotionEvent ev = MotionEvent.obtain(time, time, MotionEvent.ACTION_DOWN, 0, 0, 0);
+        mVelocityTracker.addMovement(ev);
+        ev.recycle();
+        mFakeDragBeginTime = time;
+        return true;
+    }
+
+    /**
+     * End a fake drag of the pager.
+     *
+     * @see #beginFakeDrag()
+     * @see #fakeDragBy(float)
+     */
+    public void endFakeDrag() {
+        if (!mFakeDragging) {
+            throw new IllegalStateException("No fake drag in progress. Call beginFakeDrag first.");
+        }
+
+        final VelocityTracker velocityTracker = mVelocityTracker;
+        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
+        int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(
+                velocityTracker, mActivePointerId);
+        mPopulatePending = true;
+        final int width = getClientWidth();
+        final int scrollX = getScrollX();
+        final ItemInfo ii = infoForCurrentScrollPosition();
+        final int currentPage = ii.position;
+        final float pageOffset = (((float) scrollX / width) - ii.offset) / ii.widthFactor;
+        final int totalDelta = (int) (mLastMotionX - mInitialMotionX);
+        int nextPage = determineTargetPage(currentPage, pageOffset, initialVelocity,
+                totalDelta);
+        setCurrentItemInternal(nextPage, true, true, initialVelocity);
+        endDrag();
+
+        mFakeDragging = false;
+    }
+
+    /**
+     * Fake drag by an offset in pixels. You must have called {@link #beginFakeDrag()} first.
+     *
+     * @param xOffset Offset in pixels to drag by.
+     * @see #beginFakeDrag()
+     * @see #endFakeDrag()
+     */
+    public void fakeDragBy(float xOffset) {
+        if (!mFakeDragging) {
+            throw new IllegalStateException("No fake drag in progress. Call beginFakeDrag first.");
+        }
+
+        mLastMotionX += xOffset;
+
+        float oldScrollX = getScrollX();
+        float scrollX = oldScrollX - xOffset;
+        final int width = getClientWidth();
+
+        float leftBound = width * mFirstOffset;
+        float rightBound = width * mLastOffset;
+
+        final ItemInfo firstItem = mItems.get(0);
+        final ItemInfo lastItem = mItems.get(mItems.size() - 1);
+        if (firstItem.position != 0) {
+            leftBound = firstItem.offset * width;
+        }
+        if (lastItem.position != mAdapter.getCount() - 1) {
+            rightBound = lastItem.offset * width;
+        }
+
+        if (scrollX < leftBound) {
+            scrollX = leftBound;
+        } else if (scrollX > rightBound) {
+            scrollX = rightBound;
+        }
+        // Don't lose the rounded component
+        mLastMotionX += scrollX - (int) scrollX;
+        scrollTo((int) scrollX, getScrollY());
+        pageScrolled((int) scrollX);
+
+        // Synthesize an event for the VelocityTracker.
+        final long time = SystemClock.uptimeMillis();
+        final MotionEvent ev = MotionEvent.obtain(mFakeDragBeginTime, time, MotionEvent.ACTION_MOVE,
+                mLastMotionX, 0, 0);
+        mVelocityTracker.addMovement(ev);
+        ev.recycle();
+    }
+
+    /**
+     * Returns true if a fake drag is in progress.
+     *
+     * @return true if currently in a fake drag, false otherwise.
+     *
+     * @see #beginFakeDrag()
+     * @see #fakeDragBy(float)
+     * @see #endFakeDrag()
+     */
+    public boolean isFakeDragging() {
+        return mFakeDragging;
+    }
+
+    private void onSecondaryPointerUp(MotionEvent ev) {
+        final int pointerIndex = MotionEventCompat.getActionIndex(ev);
+        final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
+        if (pointerId == mActivePointerId) {
+            // This was our active pointer going up. Choose a new
+            // active pointer and adjust accordingly.
+            final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
+            mLastMotionX = MotionEventCompat.getX(ev, newPointerIndex);
+            mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
+            if (mVelocityTracker != null) {
+                mVelocityTracker.clear();
+            }
+        }
+    }
+
+    private void endDrag() {
+        mIsBeingDragged = false;
+        mIsUnableToDrag = false;
+
+        if (mVelocityTracker != null) {
+            mVelocityTracker.recycle();
+            mVelocityTracker = null;
+        }
+    }
+
+    private void setScrollingCacheEnabled(boolean enabled) {
+        if (mScrollingCacheEnabled != enabled) {
+            mScrollingCacheEnabled = enabled;
+            if (USE_CACHE) {
+                final int size = getChildCount();
+                for (int i = 0; i < size; ++i) {
+                    final View child = getChildAt(i);
+                    if (child.getVisibility() != GONE) {
+                        child.setDrawingCacheEnabled(enabled);
+                    }
+                }
+            }
+        }
+    }
+
+    public boolean canScrollHorizontally(int direction) {
+        if (mAdapter == null) {
+            return false;
+        }
+
+        final int width = getClientWidth();
+        final int scrollX = getScrollX();
+        if (direction < 0) {
+            return (scrollX > (int) (width * mFirstOffset));
+        } else if (direction > 0) {
+            return (scrollX < (int) (width * mLastOffset));
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Tests scrollability within child views of v given a delta of dx.
+     *
+     * @param v View to test for horizontal scrollability
+     * @param checkV Whether the view v passed should itself be checked for scrollability (true),
+     *               or just its children (false).
+     * @param dx Delta scrolled in pixels
+     * @param x X coordinate of the active touch point
+     * @param y Y coordinate of the active touch point
+     * @return true if child views of v can be scrolled by delta of dx.
+     */
+    protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {
+        if (v instanceof ViewGroup) {
+            final ViewGroup group = (ViewGroup) v;
+            final int scrollX = v.getScrollX();
+            final int scrollY = v.getScrollY();
+            final int count = group.getChildCount();
+            // Count backwards - let topmost views consume scroll distance first.
+            for (int i = count - 1; i >= 0; i--) {
+                // TODO: Add versioned support here for transformed views.
+                // This will not work for transformed views in Honeycomb+
+                final View child = group.getChildAt(i);
+                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&
+                        y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&
+                        canScroll(child, true, dx, x + scrollX - child.getLeft(),
+                                y + scrollY - child.getTop())) {
+                    return true;
+                }
+            }
+        }
+
+        return checkV && ViewCompat.canScrollHorizontally(v, -dx);
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        // Let the focused view and/or our descendants get the key first
+        return super.dispatchKeyEvent(event) || executeKeyEvent(event);
+    }
+
+    /**
+     * You can call this function yourself to have the scroll view perform
+     * scrolling from a key event, just as if the event had been dispatched to
+     * it by the view hierarchy.
+     *
+     * @param event The key event to execute.
+     * @return Return true if the event was handled, else false.
+     */
+    public boolean executeKeyEvent(KeyEvent event) {
+        boolean handled = false;
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+            switch (event.getKeyCode()) {
+                case KeyEvent.KEYCODE_DPAD_LEFT:
+                    handled = arrowScroll(FOCUS_LEFT);
+                    break;
+                case KeyEvent.KEYCODE_DPAD_RIGHT:
+                    handled = arrowScroll(FOCUS_RIGHT);
+                    break;
+                case KeyEvent.KEYCODE_TAB:
+                    if (Build.VERSION.SDK_INT >= 11) {
+                        // The focus finder had a bug handling FOCUS_FORWARD and FOCUS_BACKWARD
+                        // before Android 3.0. Ignore the tab key on those devices.
+                        if (KeyEventCompat.hasNoModifiers(event)) {
+                            handled = arrowScroll(FOCUS_FORWARD);
+                        } else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) {
+                            handled = arrowScroll(FOCUS_BACKWARD);
+                        }
+                    }
+                    break;
+            }
+        }
+        return handled;
+    }
+
+    public boolean arrowScroll(int direction) {
+        View currentFocused = findFocus();
+        if (currentFocused == this) {
+            currentFocused = null;
+        } else if (currentFocused != null) {
+            boolean isChild = false;
+            for (ViewParent parent = currentFocused.getParent(); parent instanceof ViewGroup;
+                 parent = parent.getParent()) {
+                if (parent == this) {
+                    isChild = true;
+                    break;
+                }
+            }
+            if (!isChild) {
+                // This would cause the focus search down below to fail in fun ways.
+                final StringBuilder sb = new StringBuilder();
+                sb.append(currentFocused.getClass().getSimpleName());
+                for (ViewParent parent = currentFocused.getParent(); parent instanceof ViewGroup;
+                     parent = parent.getParent()) {
+                    sb.append(" => ").append(parent.getClass().getSimpleName());
+                }
+                Log.e(TAG, "arrowScroll tried to find focus based on non-child " +
+                        "current focused view " + sb.toString());
+                currentFocused = null;
+            }
+        }
+
+        boolean handled = false;
+
+        View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused,
+                direction);
+        if (nextFocused != null && nextFocused != currentFocused) {
+            if (direction == View.FOCUS_LEFT) {
+                // If there is nothing to the left, or this is causing us to
+                // jump to the right, then what we really want to do is page left.
+                final int nextLeft = getChildRectInPagerCoordinates(mTempRect, nextFocused).left;
+                final int currLeft = getChildRectInPagerCoordinates(mTempRect, currentFocused).left;
+                if (currentFocused != null && nextLeft >= currLeft) {
+                    handled = pageLeft();
+                } else {
+                    handled = nextFocused.requestFocus();
+                }
+            } else if (direction == View.FOCUS_RIGHT) {
+                // If there is nothing to the right, or this is causing us to
+                // jump to the left, then what we really want to do is page right.
+                final int nextLeft = getChildRectInPagerCoordinates(mTempRect, nextFocused).left;
+                final int currLeft = getChildRectInPagerCoordinates(mTempRect, currentFocused).left;
+                if (currentFocused != null && nextLeft <= currLeft) {
+                    handled = pageRight();
+                } else {
+                    handled = nextFocused.requestFocus();
+                }
+            }
+        } else if (direction == FOCUS_LEFT || direction == FOCUS_BACKWARD) {
+            // Trying to move left and nothing there; try to page.
+            handled = pageLeft();
+        } else if (direction == FOCUS_RIGHT || direction == FOCUS_FORWARD) {
+            // Trying to move right and nothing there; try to page.
+            handled = pageRight();
+        }
+        if (handled) {
+            playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
+        }
+        return handled;
+    }
+
+    private Rect getChildRectInPagerCoordinates(Rect outRect, View child) {
+        if (outRect == null) {
+            outRect = new Rect();
+        }
+        if (child == null) {
+            outRect.set(0, 0, 0, 0);
+            return outRect;
+        }
+        outRect.left = child.getLeft();
+        outRect.right = child.getRight();
+        outRect.top = child.getTop();
+        outRect.bottom = child.getBottom();
+
+        ViewParent parent = child.getParent();
+        while (parent instanceof ViewGroup && parent != this) {
+            final ViewGroup group = (ViewGroup) parent;
+            outRect.left += group.getLeft();
+            outRect.right += group.getRight();
+            outRect.top += group.getTop();
+            outRect.bottom += group.getBottom();
+
+            parent = group.getParent();
+        }
+        return outRect;
+    }
+
+    boolean pageLeft() {
+        if (mCurItem > 0) {
+            setCurrentItem(mCurItem-1, true);
+            return true;
+        }
+        return false;
+    }
+
+    boolean pageRight() {
+        if (mAdapter != null && mCurItem < (mAdapter.getCount()-1)) {
+            setCurrentItem(mCurItem+1, true);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * We only want the current page that is being shown to be focusable.
+     */
+    @Override
+    public void addFocusables(ArrayList<View> views, int direction, int focusableMode) {
+        final int focusableCount = views.size();
+
+        final int descendantFocusability = getDescendantFocusability();
+
+        if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {
+            for (int i = 0; i < getChildCount(); i++) {
+                final View child = getChildAt(i);
+                if (child.getVisibility() == VISIBLE) {
+                    ItemInfo ii = infoForChild(child);
+                    if (ii != null && ii.position == mCurItem) {
+                        child.addFocusables(views, direction, focusableMode);
+                    }
+                }
+            }
+        }
+
+        // we add ourselves (if focusable) in all cases except for when we are
+        // FOCUS_AFTER_DESCENDANTS and there are some descendants focusable.  this is
+        // to avoid the focus search finding layouts when a more precise search
+        // among the focusable children would be more interesting.
+        if (
+                descendantFocusability != FOCUS_AFTER_DESCENDANTS ||
+                        // No focusable descendants
+                        (focusableCount == views.size())) {
+            // Note that we can't call the superclass here, because it will
+            // add all views in.  So we need to do the same thing View does.
+            if (!isFocusable()) {
+                return;
+            }
+            if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE &&
+                    isInTouchMode() && !isFocusableInTouchMode()) {
+                return;
+            }
+            if (views != null) {
+                views.add(this);
+            }
+        }
+    }
+
+    /**
+     * We only want the current page that is being shown to be touchable.
+     */
+    @Override
+    public void addTouchables(ArrayList<View> views) {
+        // Note that we don't call super.addTouchables(), which means that
+        // we don't call View.addTouchables().  This is okay because a ViewPager
+        // is itself not touchable.
+        for (int i = 0; i < getChildCount(); i++) {
+            final View child = getChildAt(i);
+            if (child.getVisibility() == VISIBLE) {
+                ItemInfo ii = infoForChild(child);
+                if (ii != null && ii.position == mCurItem) {
+                    child.addTouchables(views);
+                }
+            }
+        }
+    }
+
+    /**
+     * We only want the current page that is being shown to be focusable.
+     */
+    @Override
+    protected boolean onRequestFocusInDescendants(int direction,
+                                                  Rect previouslyFocusedRect) {
+        int index;
+        int increment;
+        int end;
+        int count = getChildCount();
+        if ((direction & FOCUS_FORWARD) != 0) {
+            index = 0;
+            increment = 1;
+            end = count;
+        } else {
+            index = count - 1;
+            increment = -1;
+            end = -1;
+        }
+        for (int i = index; i != end; i += increment) {
+            View child = getChildAt(i);
+            if (child.getVisibility() == VISIBLE) {
+                ItemInfo ii = infoForChild(child);
+                if (ii != null && ii.position == mCurItem) {
+                    if (child.requestFocus(direction, previouslyFocusedRect)) {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
+        // Dispatch scroll events from this ViewPager.
+        if (event.getEventType() == AccessibilityEventCompat.TYPE_VIEW_SCROLLED) {
+            return super.dispatchPopulateAccessibilityEvent(event);
+        }
+
+        // Dispatch all other accessibility events from the current page.
+        final int childCount = getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final View child = getChildAt(i);
+            if (child.getVisibility() == VISIBLE) {
+                final ItemInfo ii = infoForChild(child);
+                if (ii != null && ii.position == mCurItem &&
+                        child.dispatchPopulateAccessibilityEvent(event)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    protected ViewGroup.LayoutParams generateDefaultLayoutParams() {
+        return new LayoutParams();
+    }
+
+    @Override
+    protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
+        return generateDefaultLayoutParams();
+    }
+
+    @Override
+    protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
+        return p instanceof LayoutParams && super.checkLayoutParams(p);
+    }
+
+    @Override
+    public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
+        return new LayoutParams(getContext(), attrs);
+    }
+
+    class MyAccessibilityDelegate extends AccessibilityDelegateCompat {
+
+        @Override
+        public void onInitializeAccessibilityEvent(View host, AccessibilityEvent event) {
+            super.onInitializeAccessibilityEvent(host, event);
+            event.setClassName(ViewPagerEx.class.getName());
+            final AccessibilityRecordCompat recordCompat = AccessibilityRecordCompat.obtain();
+            recordCompat.setScrollable(canScroll());
+            if (event.getEventType() == AccessibilityEventCompat.TYPE_VIEW_SCROLLED
+                    && mAdapter != null) {
+                recordCompat.setItemCount(mAdapter.getCount());
+                recordCompat.setFromIndex(mCurItem);
+                recordCompat.setToIndex(mCurItem);
+            }
+        }
+
+        @Override
+        public void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfoCompat info) {
+            super.onInitializeAccessibilityNodeInfo(host, info);
+            info.setClassName(ViewPagerEx.class.getName());
+            info.setScrollable(canScroll());
+            if (canScrollHorizontally(1)) {
+                info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD);
+            }
+            if (canScrollHorizontally(-1)) {
+                info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD);
+            }
+        }
+
+        @Override
+        public boolean performAccessibilityAction(View host, int action, Bundle args) {
+            if (super.performAccessibilityAction(host, action, args)) {
+                return true;
+            }
+            switch (action) {
+                case AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD: {
+                    if (canScrollHorizontally(1)) {
+                        setCurrentItem(mCurItem + 1);
+                        return true;
+                    }
+                } return false;
+                case AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD: {
+                    if (canScrollHorizontally(-1)) {
+                        setCurrentItem(mCurItem - 1);
+                        return true;
+                    }
+                } return false;
+            }
+            return false;
+        }
+
+        private boolean canScroll() {
+            return (mAdapter != null) && (mAdapter.getCount() > 1);
+        }
+    }
+
+    private class PagerObserver extends DataSetObserver {
+        @Override
+        public void onChanged() {
+            dataSetChanged();
+        }
+        @Override
+        public void onInvalidated() {
+            dataSetChanged();
+        }
+    }
+
+    /**
+     * Layout parameters that should be supplied for views added to a
+     * ViewPager.
+     */
+    public static class LayoutParams extends ViewGroup.LayoutParams {
+        /**
+         * true if this view is a decoration on the pager itself and not
+         * a view supplied by the adapter.
+         */
+        public boolean isDecor;
+
+        /**
+         * Gravity setting for use on decor views only:
+         * Where to position the view page within the overall ViewPager
+         * container; constants are defined in {@link android.view.Gravity}.
+         */
+        public int gravity;
+
+        /**
+         * Width as a 0-1 multiplier of the measured pager width
+         */
+        float widthFactor = 0.f;
+
+        /**
+         * true if this view was added during layout and needs to be measured
+         * before being positioned.
+         */
+        boolean needsMeasure;
+
+        /**
+         * Adapter position this view is for if !isDecor
+         */
+        int position;
+
+        /**
+         * Current child index within the ViewPager that this view occupies
+         */
+        int childIndex;
+
+        public LayoutParams() {
+            super(FILL_PARENT, FILL_PARENT);
+        }
+
+        public LayoutParams(Context context, AttributeSet attrs) {
+            super(context, attrs);
+
+            final TypedArray a = context.obtainStyledAttributes(attrs, LAYOUT_ATTRS);
+            gravity = a.getInteger(0, Gravity.TOP);
+            a.recycle();
+        }
+    }
+
+    static class ViewPositionComparator implements Comparator<View> {
+        @Override
+        public int compare(View lhs, View rhs) {
+            final LayoutParams llp = (LayoutParams) lhs.getLayoutParams();
+            final LayoutParams rlp = (LayoutParams) rhs.getLayoutParams();
+            if (llp.isDecor != rlp.isDecor) {
+                return llp.isDecor ? 1 : -1;
+            }
+            return llp.position - rlp.position;
+        }
+    }
+}
Index: library/src/main/java/com/daimajia/slider/library/Transformers/StackTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/StackTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/StackTransformer.java	(revision )
@@ -0,0 +1,14 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class StackTransformer extends BaseTransformer {
+
+	@Override
+	protected void onTransform(View view, float position) {
+		ViewHelper.setTranslationX(view,position < 0 ? 0f : -view.getWidth() * position);
+	}
+
+}
Index: library/src/main/java/com/daimajia/slider/library/Tricks/FixedSpeedScroller.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Tricks/FixedSpeedScroller.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Tricks/FixedSpeedScroller.java	(revision )
@@ -0,0 +1,35 @@
+package com.daimajia.slider.library.Tricks;
+
+import android.content.Context;
+import android.view.animation.Interpolator;
+import android.widget.Scroller;
+
+public class FixedSpeedScroller extends Scroller {
+
+    private int mDuration = 1000;
+
+    public FixedSpeedScroller(Context context) {
+        super(context);
+    }
+
+    public FixedSpeedScroller(Context context, Interpolator interpolator) {
+        super(context, interpolator);
+    }
+
+    public FixedSpeedScroller(Context context, Interpolator interpolator, int period){
+        this(context,interpolator);
+        mDuration = period;
+    }
+
+    @Override
+    public void startScroll(int startX, int startY, int dx, int dy, int duration) {
+        // Ignore received duration, use fixed one instead
+        super.startScroll(startX, startY, dx, dy, mDuration);
+    }
+
+    @Override
+    public void startScroll(int startX, int startY, int dx, int dy) {
+        // Ignore received duration, use fixed one instead
+        super.startScroll(startX, startY, dx, dy, mDuration);
+    }
+}
Index: library/src/main/res/layout/indicator_layout.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/res/layout/indicator_layout.xml	(revision )
+++ library/src/main/res/layout/indicator_layout.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="horizontal" android:layout_width="wrap_content"
+    android:id="@+id/daimajia_indicator_wrapper"
+    android:layout_gravity="center"
+    android:layout_height="wrap_content">
+</LinearLayout>
\ No newline at end of file
Index: library/proguard-rules.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/proguard-rules.txt	(revision )
+++ library/proguard-rules.txt	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the ProGuard
+# include property in project.properties.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
\ No newline at end of file
Index: library/src/main/java/com/daimajia/slider/library/Transformers/ForegroundToBackgroundTransformer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- library/src/main/java/com/daimajia/slider/library/Transformers/ForegroundToBackgroundTransformer.java	(revision )
+++ library/src/main/java/com/daimajia/slider/library/Transformers/ForegroundToBackgroundTransformer.java	(revision )
@@ -0,0 +1,26 @@
+package com.daimajia.slider.library.Transformers;
+
+import android.view.View;
+
+import com.nineoldandroids.view.ViewHelper;
+
+public class ForegroundToBackgroundTransformer extends BaseTransformer {
+
+	@Override
+	protected void onTransform(View view, float position) {
+		final float height = view.getHeight();
+		final float width = view.getWidth();
+		final float scale = min(position > 0 ? 1f : Math.abs(1f + position), 0.5f);
+
+		ViewHelper.setScaleX(view,scale);
+        ViewHelper.setScaleY(view,scale);
+        ViewHelper.setPivotX(view,width * 0.5f);
+        ViewHelper.setPivotY(view,height * 0.5f);
+        ViewHelper.setTranslationX(view,position > 0 ? width * position : -width * position * 0.25f);
+	}
+
+	private static final float min(float val, float min) {
+		return val < min ? min : val;
+	}
+
+}
